// Generated by CoffeeScript 1.8.0

/*
 * The MIT License (MIT)
 * 
 * Copyright ( c ) 2014 Teem2 LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

(function() {
  var hackstyle,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  hackstyle = (function() {
    var origstyle, stylemap, styletap;
    stylemap = {
      left: 'x',
      top: 'y',
      'background-color': 'bgcolor'
    };
    origstyle = $.style;
    styletap = function(elem, name, value) {
      var returnval, view;
      returnval = origstyle.apply(this, arguments);
      name = stylemap[name] || name;
      view = elem.$view;
      if (view[name] !== value) {
        view.setAttribute(name, value, true);
      }
      return returnval;
    };
    return function(active) {
      if (active) {
        return $.style = styletap;
      } else {
        return $.style = origstyle;
      }
    };
  })();

  window.dr = (function() {
    var Class, Eventable, Events, Idle, InputText, Keyboard, Layout, Module, Mouse, Node, Sprite, StartEventable, State, Text, View, Window, capabilities, compiler, constraintScopes, debug, dom, exports, idle, ignoredAttributes, mixOf, moduleKeywords, mouseEvents, querystring, showWarnings, warnings, _initConstraints;
    mixOf = function() {
      var Mixed, base, i, method, mixin, mixins, name, _i, _ref;
      base = arguments[0], mixins = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      Mixed = (function(_super) {
        __extends(Mixed, _super);

        function Mixed() {
          return Mixed.__super__.constructor.apply(this, arguments);
        }

        return Mixed;

      })(base);
      for (i = _i = mixins.length - 1; _i >= 0; i = _i += -1) {
        mixin = mixins[i];
        _ref = mixin.prototype;
        for (name in _ref) {
          method = _ref[name];
          Mixed.prototype[name] = method;
        }
      }
      return Mixed;
    };

    /**
     * @class Events
     * @private
     * A lightweight event system, used internally.
     */
    Events = {

      /**
       * Binds an event to the current scope
       * @param {String} ev the name of the event
       * @param {Function} callback called when the event is fired
       */
      bind: function(ev, callback) {
        var evs, name, _base, _i, _len;
        evs = ev.split(' ');
        if (!(this.hasOwnProperty('events') && this.events)) {
          this.events = {};
        }
        for (_i = 0, _len = evs.length; _i < _len; _i++) {
          name = evs[_i];
          (_base = this.events)[name] || (_base[name] = []);
          this.events[name].push(callback);
        }
        return this;
      },

      /**
       * Binds an event to the current scope, automatically unbinds when the event fires
       * @param {String} ev the name of the event
       * @param {Function} callback called when the event is fired
       */
      one: function(ev, callback) {
        this.bind(ev, function() {
          this.unbind(ev, arguments.callee);
          return callback.apply(this, arguments);
        });
        return this;
      },

      /**
       * Fires an event
       * @param {String} ev the name of the event to fire
       */
      trigger: function() {
        var args, callback, ev, list, _i, _len, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        ev = args.shift();
        list = this.hasOwnProperty('events') && ((_ref = this.events) != null ? _ref[ev] : void 0);
        if (!list) {
          return;
        }
        for (_i = 0, _len = list.length; _i < _len; _i++) {
          callback = list[_i];
          if (callback.apply(this, args) === false) {
            break;
          }
        }
        return this;
      },

      /**
       * Listens for an event on a specific scope
       * @param {Object} obj scope to listen for events on
       * @param {String} ev the name of the event
       * @param {Function} callback called when the event is fired
       */
      listenTo: function(obj, ev, callback) {
        obj.bind(ev, callback);
        this.listeningTo || (this.listeningTo = []);
        this.listeningTo.push({
          obj: obj,
          ev: ev,
          callback: callback
        });
        return this;
      },

      /**
       * Only listens for an event one time
       * @param {Object} obj scope to listen for events on
       * @param {String} ev the name of the event
       * @param {Function} callback called when the event is fired
       */
      listenToOnce: function(obj, ev, callback) {
        var listeningToOnce;
        listeningToOnce = this.listeningToOnce || (this.listeningToOnce = []);
        listeningToOnce.push(obj);
        obj.one(ev, function() {
          var idx;
          idx = listeningToOnce.indexOf(obj);
          if (idx !== -1) {
            listeningToOnce.splice(idx, 1);
          }
          return callback.apply(this, arguments);
        });
        return this;
      },

      /**
       * Stops listening for an event on a given scope
       * @param {Object} obj scope to listen for events on
       * @param {String} ev the name of the event
       * @param {Function} callback called when the event would have been fired
       */
      stopListening: function(obj, ev, callback) {
        var idx, index, listeningTo, val, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
        if (obj) {
          obj.unbind(ev, callback);
          _ref = [this.listeningTo, this.listeningToOnce];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            listeningTo = _ref[_i];
            if (!listeningTo) {
              continue;
            }
            idx = listeningTo.indexOf(obj);
            if (idx > -1) {
              listeningTo.splice(idx, 1);
            } else {
              for (index = _j = 0, _len1 = listeningTo.length; _j < _len1; index = ++_j) {
                val = listeningTo[index];
                if (obj === val.obj && ev === val.ev && callback === val.callback) {
                  listeningTo.splice(index, 1);
                  break;
                }
              }
            }
          }
        } else {
          _ref1 = this.listeningTo;
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            _ref2 = _ref1[_k], obj = _ref2.obj, ev = _ref2.ev, callback = _ref2.callback;
            obj.unbind(ev, callback);
          }
          this.listeningTo = void 0;
        }
        return this;
      },

      /**
       * Stops listening for an event on the current scope
       * @param {String} ev the name of the event
       * @param {Function} callback called when the event would have been fired
       */
      unbind: function(ev, callback) {
        var cb, evs, i, list, name, _i, _j, _len, _len1, _ref;
        if (!ev) {
          this.events = {};
          return this;
        }
        evs = ev.split(' ');
        for (_i = 0, _len = evs.length; _i < _len; _i++) {
          name = evs[_i];
          list = (_ref = this.events) != null ? _ref[name] : void 0;
          if (!list) {
            continue;
          }
          if (!callback) {
            delete this.events[name];
            continue;
          }
          for (i = _j = 0, _len1 = list.length; _j < _len1; i = ++_j) {
            cb = list[i];
            if (!(cb === callback)) {
              continue;
            }
            list = list.slice();
            list.splice(i, 1);
            this.events[name] = list;
            break;
          }
        }
        return this;
      }
    };

    /**
     * @class Module
     * @private
     * Adds basic mixin support.
     */
    moduleKeywords = ['included', 'extended'];
    Module = (function() {
      function Module() {}


      /**
       * Includes a mixin in the current scope
       * @param {Object} obj the object to be mixed in
       */

      Module.include = function(obj) {
        var key, value, _ref;
        if (!obj) {
          throw new Error('include(obj) requires obj');
        }
        for (key in obj) {
          value = obj[key];
          if (__indexOf.call(moduleKeywords, key) < 0) {
            this.prototype[key] = value;
          }
        }
        if ((_ref = obj.included) != null) {
          _ref.call(this, obj);
        }
        return this;
      };

      return Module;

    })();

    /**
     * @class Eventable
     * @extends Module
     * The baseclass used by everything in dreem. Adds higher level event APIs.
     */
    Eventable = (function(_super) {

      /**
       * @method include
       * @hide
       */
      var eventlock, typemappings;

      __extends(Eventable, _super);

      function Eventable() {
        return Eventable.__super__.constructor.apply(this, arguments);
      }

      Eventable.include(Events);

      typemappings = {
        number: parseFloat,
        boolean: function(val) {
          if (typeof val === 'string') {
            return val === 'true';
          } else {
            return !!val;
          }
        },
        string: function(val) {
          return val + '';
        },
        json: function(val) {
          return JSON.parse(val);
        },
        expression: function(val) {
          if (typeof val !== 'string') {
            return val;
          }
          return eval(val);
        }
      };

      eventlock = {};

      Eventable.prototype._coerceType = function(name, value) {
        var type;
        type = this.types[name];
        if (type) {
          if (!typemappings[type]) {
            showWarnings(["Invalid type '" + type + "' for attribute '" + name + "', must be one of: " + (Object.keys(typemappings).join(', '))]);
            return;
          }
          value = typemappings[type](value);
        } else if (value == null) {
          value = '';
        }
        return value;
      };

      Eventable.prototype._setDefaults = function(attributes, defaults) {
        var key, value, _results;
        if (defaults == null) {
          defaults = {};
        }
        _results = [];
        for (key in defaults) {
          value = defaults[key];
          if (!(key in attributes)) {
            _results.push(attributes[key] = defaults[key]);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };


      /**
       * Sets an attribute, calls a setter if there is one, then sends an event with the new value
       * @param {String} name the name of the attribute to set
       * @param value the value to set to
       */

      Eventable.prototype.setAttribute = function(name, value, skipcoercion) {
        var _name;
        if (!skipcoercion) {
          value = this._coerceType(name, value);
        }
        if (typeof this[_name = "set_" + name] === "function") {
          this[_name](value);
        }
        this[name] = value;
        this.sendEvent(name, value);
        return this;
      };


      /**
       * Sends an event
       * @param {String} name the name of the event to send
       * @param value the value to send with the event
       */

      Eventable.prototype.sendEvent = function(name, value) {
        var lockkey, _ref;
        lockkey = "c" + name;
        if (eventlock[name] === this && eventlock[lockkey]++ > 0) {
          return this;
        }
        if (((_ref = this.events) != null ? _ref[name] : void 0) && eventlock[name] !== this) {
          eventlock[name] = this;
          eventlock[lockkey] = 0;
          this.trigger(name, value, this);
          eventlock = {};
        }
        return this;
      };


      /**
       * Calls setAttribute for each name/value pair in the attributes object
       * @param {Object} attributes An object of name/value pairs to be set
       */

      Eventable.prototype.setAttributes = function(attributes) {
        var name, value;
        for (name in attributes) {
          value = attributes[name];
          this.setAttribute(name, value);
        }
        return this;
      };

      return Eventable;

    })(Module);
    capabilities = {
      localStorage: (function() {
        var e, mod;
        mod = 'dr';
        try {
          localStorage.setItem(mod, mod);
          localStorage.removeItem(mod);
          return true;
        } catch (_error) {
          e = _error;
          return false;
        }
      })(),
      touch: 'ontouchstart' in window || 'onmsgesturechange' in window
    };
    querystring = window.location.search;
    debug = querystring.indexOf('debug') > 0;
    compiler = (function() {
      var cacheData, cacheKey, compile, compileCache, exports, findBindings, nocache, scriptCache, strict, transform, usecache;
      nocache = querystring.indexOf('nocache') > 0;
      strict = querystring.indexOf('strict') > 0;
      if (!nocache) {
        usecache = capabilities.localStorage;
      }
      cacheKey = "dreemcache";
      cacheData = localStorage.getItem(cacheKey);
      if (usecache && cacheData && cacheData.length < 5000000) {
        compileCache = JSON.parse(cacheData);
      } else {
        localStorage.clear();
        compileCache = {
          bindings: {},
          script: {
            coffee: {}
          }
        };
        if (usecache) {
          localStorage[cacheKey] = JSON.stringify(compileCache);
        }
      }
      window.addEventListener('unload', function() {
        if (usecache) {
          return localStorage[cacheKey] = JSON.stringify(compileCache);
        }
      });
      findBindings = (function() {
        var bindingCache, propertyBindings, scopes;
        bindingCache = compileCache.bindings;
        scopes = null;
        propertyBindings = {
          MemberExpression: function(n) {
            var name;
            name = n.property.name;
            n = n.object;
            scopes.push({
              binding: acorn.stringify(n),
              property: name
            });
            return true;
          }
        };
        return function(expression) {
          var ast;
          if (usecache && expression in bindingCache) {
            return bindingCache[expression];
          }
          ast = acorn.parse(expression);
          scopes = [];
          acorn.walkDown(ast, propertyBindings);
          return bindingCache[expression] = scopes;
        };
      })();
      transform = (function() {
        var coffeeCache, compilers;
        coffeeCache = compileCache.script.coffee;
        compilers = {
          coffee: function(script) {
            var error;
            if (usecache && script in coffeeCache) {
              return coffeeCache[script];
            }
            if (!window.CoffeeScript) {
              console.warn('missing coffee-script.js include');
              return;
            }
            try {
              if (script) {
                return coffeeCache[script] = CoffeeScript.compile(script, {
                  bare: true
                });
              }
            } catch (_error) {
              error = _error;
              return showWarnings(["error " + error + " compiling script\r\n" + script]);
            }
          }
        };
        return function(script, name) {
          if (script == null) {
            script = '';
          }
          if (!(name in compilers)) {
            return script;
          }
          return compilers[name](script);
        };
      })();
      scriptCache = {};
      compile = function(script, args, name) {
        var argstring, e, func, key;
        if (script == null) {
          script = '';
        }
        if (args == null) {
          args = [];
        }
        if (name == null) {
          name = '';
        }
        argstring = args.join();
        key = script + argstring + name;
        if (key in scriptCache) {
          return scriptCache[key];
        }
        try {
          if (debug && name) {
            if (strict) {
              script = "\"use strict\"\n" + script;
            }
            func = new Function("return function " + name + "(" + argstring + "){" + script + "}")();
          } else {
            func = new Function(args, script);
          }
          return scriptCache[key] = func;
        } catch (_error) {
          e = _error;
          return console.error('failed to compile', e.toString(), args, script);
        }
      };
      return exports = {
        compile: compile,
        transform: transform,
        findBindings: findBindings
      };
    })();
    constraintScopes = [];
    _initConstraints = function() {
      var constraint, _i, _len;
      for (_i = 0, _len = constraintScopes.length; _i < _len; _i++) {
        constraint = constraintScopes[_i];
        constraint._bindConstraints();
      }
      return constraintScopes = [];
    };

    /**
     * @aside guide constraints
     * @class dr.node
     * @extends Eventable
     * The nonvisual base class for everything in dreem. Handles parent/child relationships between tags.
     *
     * Nodes can contain methods, handlers, setters, [constraints](#!/guide/constraints), attributes and other node instances.
     *
     * Here we define a data node that contains movie data.
     *
     *     @example
     *     <node id="data">
     *       <node>
     *         <attribute name="title" type="string" value="Bill and Teds Excellent Adventure"></attribute>
     *         <attribute name="type" type="string" value="movie"></attribute>
     *         <attribute name="year" type="string" value="1989"></attribute>
     *         <attribute name="length" type="number" value="89"></attribute>
     *       </node>
     *       <node>
     *         <attribute name="title" type="string" value="Waynes World"></attribute>
     *         <attribute name="type" type="string" value="movie"></attribute>
     *         <attribute name="year" type="string" value="1992"></attribute>
     *         <attribute name="length" type="number" value="94"></attribute>
     *       </node>
     *     </node>
     *
     * This node defines a set of math helper methods. The node provides a tidy container for these related utility functions.
     *
     *     @example
     *     <node id="utils">
     *       <method name="add" args="a,b">
     *         return a+b;
     *       </method>
     *       <method name="subtract" args="a,b">
     *         return a-b;
     *       </method>
     *     </node>
     *
     * You can also create a sub-class of node to contain non visual functionality. Here is an example of an inches to metric conversion class that is instantiated with the inches value and can convert it to either cm or m.
     *
     *     @example
     *
     *     <class name="inchesconverter" extends="node">
     *       <attribute name="inchesval" type="number" value="0"></attribute>
     *
     *       <method name="centimetersval">
     *         return this.inchesval*2.54;
     *       </method>
     *
     *       <method name="metersval">
     *         return (this.inchesval*2.54)/100;
     *       </method>
     *     </class>
     *
     *     <inchesconverter id="conv" inchesval="2"></inchesconverter>
     *
     *     <simplelayout axis="y"></simplelayout>
     *     <text text="${conv.inchesval + ' inches'}"></text>
     *     <text text="${conv.centimetersval() + ' cm'}"></text>
     *     <text text="${conv.metersval() + ' m'}"></text>
     *
     *
     */
    Node = (function(_super) {

      /**
       * @cfg {String} name
       * Names this node in its parent scope so it can be referred to later.
       */

      /**
       * @cfg {String} id
       * Gives this node a global ID, which can be looked up in the global window object.
       * Take care to not override builtin globals, or override your own instances!
       */

      /**
       * @cfg {String} scriptincludes
       * A comma separated list of URLs to javascript includes required as dependencies. Useful if you need to ensure a third party library is available.
       */

      /**
       * @cfg {String} scriptincludeserror
       * An error to show if scriptincludes fail to load
       */
      var earlyattributes, lateattributes, matchConstraint, _eventCallback, _installMethod;

      __extends(Node, _super);

      matchConstraint = /\${(.+)}/;

      earlyattributes = ['parent', 'name'];

      lateattributes = ['data'];

      function Node(el, attributes) {
        var args, deferbindings, ev, method, name, reference, script, skiponinit, value, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
        if (attributes == null) {
          attributes = {};
        }

        /**
         * @property {dr.node[]} subnodes
         * @readonly
         * An array of this node's child nodes
         */
        this.subnodes = [];
        this.types = (_ref = attributes.$types) != null ? _ref : {};
        delete attributes.$types;
        skiponinit = attributes.$skiponinit;
        delete attributes.$skiponinit;
        deferbindings = attributes.$deferbindings;
        delete attributes.$deferbindings;

        /*
         * @property {String} $textcontent
         * @readonly
         * Contains the textual contents of this node, if any
         */
        if (el != null ? el.textContent : void 0) {
          attributes.$textcontent = el.textContent;
        }
        if (attributes.$methods) {
          this.installMethods(attributes.$methods, attributes.$tagname);
          delete attributes.$methods;
        }
        if (attributes.$handlers) {
          this.installHandlers(attributes.$handlers, attributes.$tagname);
          _ref1 = attributes.$handlers;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            _ref2 = _ref1[_i], ev = _ref2.ev, name = _ref2.name, script = _ref2.script, args = _ref2.args, reference = _ref2.reference, method = _ref2.method;
            ev = ev.substr(2);
            if (__indexOf.call(mouseEvents, ev) >= 0) {
              if (attributes.clickable !== "false") {
                attributes.clickable = true;
              }
            }
          }
          delete attributes.$handlers;
        }
        if (!deferbindings) {
          this._bindHandlers();
        }
        for (_j = 0, _len1 = earlyattributes.length; _j < _len1; _j++) {
          name = earlyattributes[_j];
          if (name in attributes) {
            this.setAttribute(name, attributes[name]);
          }
        }
        for (name in attributes) {
          value = attributes[name];
          if (__indexOf.call(lateattributes, name) >= 0 || __indexOf.call(earlyattributes, name) >= 0) {
            continue;
          }
          this.bindAttribute(name, value, attributes.$tagname);
        }
        for (_k = 0, _len2 = lateattributes.length; _k < _len2; _k++) {
          name = lateattributes[_k];
          if (name in attributes) {
            this.bindAttribute(name, attributes[name], attributes.$tagname);
          }
        }
        if (this.constraints) {
          constraintScopes.push(this);
        }
        if (!deferbindings) {
          this._bindHandlers(true);
        }

        /**
         * @event oninit
         * Fired when this node and all its children are completely initialized
         * @param {dr.node} node The dr.node that fired the event
         */

        /**
         * @property {Boolean} inited
         * @readonly
         * True when this node and all its children are completely initialized
         */
        if (!skiponinit) {
          if (!this.inited) {
            this.inited = true;
            this.sendEvent('init', this);
          }
        }
      }

      Node.prototype.installMethods = function(methods, tagname, scope, callbackscope) {
        var allocation, args, method, methodlist, name, _i, _len, _ref;
        if (scope == null) {
          scope = this;
        }
        if (callbackscope == null) {
          callbackscope = this;
        }
        for (name in methods) {
          methodlist = methods[name];
          for (_i = 0, _len = methodlist.length; _i < _len; _i++) {
            _ref = methodlist[_i], method = _ref.method, args = _ref.args, allocation = _ref.allocation;
            _installMethod(scope, name, compiler.compile(method, args, "" + tagname + "$" + name).bind(callbackscope), allocation);
          }
        }
      };

      Node.prototype.installHandlers = function(handlers, tagname, scope) {
        var args, ev, handler, handlerobj, method, name, reference, script, _i, _len;
        if (scope == null) {
          scope = this;
        }
        if (this.handlers == null) {
          this.handlers = [];
        }
        if (this.latehandlers == null) {
          this.latehandlers = [];
        }
        for (_i = 0, _len = handlers.length; _i < _len; _i++) {
          handler = handlers[_i];
          ev = handler.ev, name = handler.name, script = handler.script, args = handler.args, reference = handler.reference, method = handler.method;
          ev = ev.substr(2);
          if (method) {
            handler.callback = scope[method];
          } else {
            handler.callback = _eventCallback(ev, script, scope, tagname, args);
          }
          handlerobj = {
            scope: this,
            ev: ev,
            name: name,
            callback: handler.callback,
            reference: reference
          };
          if (reference) {
            this.latehandlers.push(handlerobj);
          } else {
            this.handlers.push(handlerobj);
          }
        }
      };

      Node.prototype.removeHandlers = function(handlers, tagname, scope) {
        var args, ev, handler, method, name, reference, refeval, script, _i, _len;
        if (scope == null) {
          scope = this;
        }
        for (_i = 0, _len = handlers.length; _i < _len; _i++) {
          handler = handlers[_i];
          ev = handler.ev, name = handler.name, script = handler.script, args = handler.args, reference = handler.reference, method = handler.method;
          ev = ev.substr(2);
          if (reference != null) {
            refeval = this._valueLookup(reference)();
            scope.stopListening(refeval, ev, handler.callback);
          } else {
            scope.unbind(ev, handler.callback);
          }
        }
      };

      Node.prototype.bindAttribute = function(name, value, tagname) {
        var constraint;
        if (value) {
          constraint = typeof value.match === "function" ? value.match(matchConstraint) : void 0;
        }
        if (constraint) {
          return this._applyConstraint(name, constraint[1]);
        } else if (name.indexOf('on') === 0) {
          name = name.substr(2);
          return this.bind(name, _eventCallback(name, value, this, tagname));
        } else {
          return this.setAttribute(name, value);
        }
      };

      Node.prototype.initConstraints = function() {
        _initConstraints();
        return this;
      };

      _eventCallback = function(name, script, scope, tagname, fnargs) {
        var js;
        if (tagname == null) {
          tagname = '';
        }
        if (fnargs == null) {
          fnargs = ['value'];
        }
        js = compiler.compile(script, fnargs, "" + tagname + "$on" + name);
        return function() {
          var args;
          if (arguments.length) {
            args = arguments;
          } else if (name in scope) {
            args = [scope[name]];
          } else {
            args = [];
          }
          return js.apply(scope, args);
        };
      };

      _installMethod = function(scope, methodname, method, allocation) {
        var meth, supr;
        if (methodname in scope) {
          supr = scope[methodname];
          meth = method;
          return scope[methodname] = function() {
            supr.apply(scope, arguments);
            return meth.apply(scope, arguments);
          };
        } else {
          return scope[methodname] = method;
        }
      };

      Node.prototype._applyConstraint = function(property, expression) {
        var bindexpression, bindings, scope, scopes, _i, _len;
        if (this.constraints == null) {
          this.constraints = {};
        }
        this.constraints[property] = {
          expression: expression,
          bindings: {}
        };
        bindings = this.constraints[property].bindings;
        scopes = compiler.findBindings(expression);
        for (_i = 0, _len = scopes.length; _i < _len; _i++) {
          scope = scopes[_i];
          bindexpression = scope.binding;
          if (bindings[bindexpression] == null) {
            bindings[bindexpression] = [];
          }
          bindings[bindexpression].push(scope);
        }
      };

      Node.prototype._valueLookup = function(bindexpression) {
        return compiler.compile('return ' + bindexpression).bind(this);
      };

      Node.prototype._bindConstraints = function() {
        var bindexpression, binding, bindinglist, bindings, boundref, constraint, expression, fn, name, property, _i, _len, _ref;
        _ref = this.constraints;
        for (name in _ref) {
          constraint = _ref[name];
          bindings = constraint.bindings, expression = constraint.expression;
          fn = this._valueLookup(expression);
          constraint = this._constraintCallback(name, fn);
          for (bindexpression in bindings) {
            bindinglist = bindings[bindexpression];
            boundref = this._valueLookup(bindexpression)();
            if (!boundref) {
              showWarnings(["Could not bind constraint " + bindexpression]);
              continue;
            }
            if (boundref == null) {
              boundref = boundref.$view;
            }
            for (_i = 0, _len = bindinglist.length; _i < _len; _i++) {
              binding = bindinglist[_i];
              property = binding.property;
              if (typeof boundref.bind === "function") {
                boundref.bind(property, constraint);
              }
            }
          }
          this.setAttribute(name, fn());
        }
      };

      Node.prototype._bindHandlers = function(isLate) {
        var binding, bindings, callback, defer, ev, name, reference, refeval, scope, _i, _len;
        bindings = isLate ? this.latehandlers : this.handlers;
        if (!bindings) {
          return;
        }
        defer = [];
        for (_i = 0, _len = bindings.length; _i < _len; _i++) {
          binding = bindings[_i];
          scope = binding.scope, name = binding.name, ev = binding.ev, callback = binding.callback, reference = binding.reference;
          if (reference) {
            refeval = this._valueLookup(reference)();
            if (refeval instanceof Eventable) {
              scope.listenTo(refeval, ev, callback);
            } else {
              defer.push(binding);
              continue;
            }
          } else {
            scope.bind(ev, callback);
            if (scope[ev]) {
              scope.sendEvent(ev, scope[ev]);
            }
          }
        }
        if (defer.length) {
          if (isLate) {
            this.latehandlers = defer;
          } else {
            this.handlers = defer;
          }
          setTimeout((function(_this) {
            return function() {
              return _this._bindHandlers(isLate);
            };
          })(this), 0);
          return;
        }
        if (isLate) {
          this.latehandlers = [];
        } else {
          this.handlers = [];
        }
      };

      Node.prototype._constraintCallback = function(name, fn) {
        return (function constraintCallback(){;
        this.setAttribute(name, fn());
        return }).bind(this);
      };

      Node.prototype.set_parent = function(parent) {
        if (parent instanceof Node) {
          if (this.name) {
            parent[this.name] = this;
          }
          parent.subnodes.push(this);

          /**
           * @event onsubnodes
           * Fired when this node's subnodes array has changed
           * @param {dr.node} node The dr.node that fired the event
           */
          return parent.sendEvent('subnodes', this);
        }
      };

      Node.prototype.set_name = function(name) {
        return this.parent[name] = this;
      };

      Node.prototype.set_id = function(id) {
        return window[id] = this;
      };

      Node.prototype._removeFromParent = function(name) {
        var arr, index;
        if (!this.parent) {
          return;
        }
        arr = this.parent[name];
        index = arr.indexOf(this);
        if (index !== -1) {
          arr.splice(index, 1);
          this.parent.sendEvent(name, arr[index]);
        }
      };

      Node.prototype._findParents = function(name, value) {
        var out, p;
        out = [];
        p = this;
        while (p) {
          if (name in p && p[name] === value) {
            out.push(p);
          }
          p = p.parent;
        }
        return out;
      };

      Node.prototype._findInParents = function(name) {
        var p;
        p = this.parent;
        while (p) {
          if (name in p) {
            return p[name];
          }
          p = p.parent;
        }
      };


      /**
       * @method destroy
       * Destroys this node
       */


      /**
       * @ignore
       */

      Node.prototype.destroy = function(skipevents) {

        /**
         * @event ondestroy
         * Fired when this node and all its children are about to be destroyed
         * @param {dr.node} node The dr.node that fired the event
         */
        var subnode, _i, _len, _ref, _ref1;
        this.sendEvent('destroy', this);
        if (this.listeningTo) {
          this.stopListening();
        }
        this.unbind();
        if (((_ref = this.parent) != null ? _ref[this.name] : void 0) === this) {
          delete this.parent[this.name];
        }
        _ref1 = this.subnodes;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          subnode = _ref1[_i];
          if (subnode != null) {
            subnode.destroy(true);
          }
        }
        if (!skipevents) {
          return this._removeFromParent('subnodes');
        }
      };

      return Node;

    })(Eventable);

    /**
     * @class Sprite
     * @private
     * Abstracts the underlying visual primitives (currently HTML) from dreem's view system.
     */
    Sprite = (function() {
      var fcamelCase, lastTouchDown, noop, rdashAlpha, stylemap, styleval;

      noop = function() {};

      stylemap = {
        x: 'left',
        y: 'top',
        bgcolor: 'backgroundColor',
        visible: 'display'
      };

      styleval = {
        display: function(isVisible) {
          if (isVisible) {
            return '';
          } else {
            return 'none';
          }
        }
      };

      fcamelCase = function(all, letter) {
        return letter.toUpperCase();
      };

      rdashAlpha = /-([\da-z])/gi;

      function Sprite(jqel, view, tagname) {
        if (tagname == null) {
          tagname = 'div';
        }
        this.handle = __bind(this.handle, this);
        this.touchHandler = __bind(this.touchHandler, this);
        this.animate = __bind(this.animate, this);
        if (jqel == null) {
          this.el = document.createElement(tagname);
          this.el.$init = true;
        } else if (jqel instanceof HTMLElement) {
          this.el = jqel;
        }
        this.el.$view = view;
        this.el.setAttribute('class', 'sprite');
      }

      Sprite.prototype.setStyle = function(name, value, internal, el) {
        if (el == null) {
          el = this.el;
        }
        if (value == null) {
          value = '';
        }
        if (name in stylemap) {
          name = stylemap[name];
        }
        if (name in styleval) {
          value = styleval[name](value);
        } else if (name.match(rdashAlpha)) {
          name = name.replace(rdashAlpha, fcamelCase);
          if (debug && !internal) {
            console.warn("Setting unknown CSS property " + name + " = " + value + " on ", this.el.$view);
          }
        }
        return el.style[name] = value;
      };

      Sprite.prototype.set_parent = function(parent) {
        if (parent instanceof Sprite) {
          parent = parent.el;
        }
        return parent.appendChild(this.el);
      };

      Sprite.prototype.set_id = function(id) {
        return this.el.setAttribute('id', id);
      };

      Sprite.prototype.animate = function() {
        var name, value, _ref;
        if (this.jqel == null) {
          this.jqel = $(this.el);
        }
        _ref = arguments[0];
        for (name in _ref) {
          value = _ref[name];
          if (name in stylemap) {
            arguments[0][stylemap[name]] = value;
            delete arguments[0][name];
          }
        }
        return this.jqel.animate.apply(this.jqel, arguments);
      };

      Sprite.prototype.sendMouseEvent = function(type, first) {
        var simulatedEvent;
        simulatedEvent = document.createEvent('MouseEvent');
        simulatedEvent.initMouseEvent(type, true, true, window, 1, first.pageX, first.pageY, first.clientX, first.clientY, false, false, false, false, 0, null);
        first.target.dispatchEvent(simulatedEvent);
        if (first.target.$view && first.target.$view.$tagname !== 'inputtext') {
          return event.preventDefault();
        }
      };

      lastTouchDown = null;

      Sprite.prototype.touchHandler = function(event) {
        var first, touches;
        touches = event.changedTouches;
        first = touches[0];
        switch (event.type) {
          case 'touchstart':
            this.sendMouseEvent('mouseover', first);
            this.sendMouseEvent('mousedown', first);
            return lastTouchDown = first.target;
          case 'touchmove':
            return this.sendMouseEvent('mousemove', first);
          case 'touchend':
            this.sendMouseEvent('mouseup', first);
            if (lastTouchDown === first.target) {
              this.sendMouseEvent('click', first);
              return lastTouchDown = null;
            }
        }
      };

      Sprite.prototype.set_clickable = function(clickable) {
        this.__clickable = clickable;
        this.__updatePointerEvents();
        this.setStyle('cursor', (clickable ? 'pointer' : ''), true);
        if (capabilities.touch) {
          document.addEventListener('touchstart', this.touchHandler, true);
          document.addEventListener('touchmove', this.touchHandler, true);
          document.addEventListener('touchend', this.touchHandler, true);
          return document.addEventListener('touchcancel', this.touchHandler, true);
        }
      };

      Sprite.prototype.set_clip = function(clip) {
        this.__clip = clip;
        return this.__updateOverflow();
      };

      Sprite.prototype.set_scrollable = function(scrollable) {
        this.__scrollable = scrollable;
        this.__updateOverflow();
        return this.__updatePointerEvents();
      };

      Sprite.prototype.__updateOverflow = function() {
        return this.setStyle('overflow', this.__scrollable ? 'auto' : this.__clip ? 'hidden' : '');
      };

      Sprite.prototype.__updatePointerEvents = function() {
        return this.setStyle('pointer-events', (this.__clickable || this.__scrollable ? 'auto' : 'none'), true);
      };

      Sprite.prototype.destroy = function() {
        this.el.parentNode.removeChild(this.el);
        return this.el = this.jqel = null;
      };

      Sprite.prototype.setText = function(txt) {
        if (txt != null) {
          return this.el.innerHTML = txt;
        }
      };

      Sprite.prototype.getText = function(textOnly) {
        if (textOnly) {
          return this.el.innerText;
        } else {
          return this.el.innerHTML;
        }
      };

      Sprite.prototype.value = function(value) {
        if (!this.input) {
          return;
        }
        if (value != null) {
          return this.input.value = value;
        } else {
          return this.input.value;
        }
      };

      Sprite.prototype.measureTextSize = function(multiline, width, resize) {
        if (multiline) {
          this.setStyle('width', width);
          this.setStyle('height', 'auto');
          this.setStyle('whiteSpace', 'normal');
        } else {
          if (resize) {
            this.setStyle('width', 'auto');
          }
          if (resize) {
            this.setStyle('height', 'auto');
          }
          this.setStyle('whiteSpace', '');
        }
        return {
          width: this.el.clientWidth,
          height: this.el.clientHeight
        };
      };

      Sprite.prototype.handle = function(event) {
        var view;
        view = event.target.$view;
        if (!view) {
          return;
        }
        return view.sendEvent(event.type, view);
      };

      Sprite.prototype.createTextElement = function() {
        return this.el.setAttribute('class', 'sprite sprite-text noselect');
      };

      Sprite.prototype.createInputtextElement = function(text, multiline, width, height) {
        var input;
        this.el.setAttribute('class', 'sprite noselect');
        if (multiline) {
          input = document.createElement('textarea');
        } else {
          input = document.createElement('input');
          input.setAttribute('type', 'text');
        }
        input.setAttribute('value', text);
        input.setAttribute('class', 'sprite-inputtext');
        if (width) {
          this.setStyle('width', width, true, input);
        }
        if (height) {
          this.setStyle('height', height, true, input);
        }
        this.el.appendChild(input);
        input.$view = this.el.$view;
        $(input).on('focus blur', this.handle);
        return this.input = input;
      };

      Sprite.prototype.getInputtextHeight = function() {
        var borderH, h, paddingH;
        h = parseInt($(this.input).css('height'));
        borderH = parseInt($(this.el).css('border-top-width')) + parseInt($(this.el).css('border-bottom-width'));
        paddingH = parseInt($(this.el).css('padding-top')) + parseInt($(this.el).css('padding-bottom'));
        return h + borderH + paddingH;
      };

      Sprite.prototype.getAbsolute = function() {
        var pos;
        if (this.jqel == null) {
          this.jqel = $(this.el);
        }
        pos = this.jqel.offset();
        return {
          x: pos.left,
          y: pos.top
        };
      };

      Sprite.prototype.set_class = function(classname) {
        return this.el.setAttribute('class', classname);
      };

      return Sprite;

    })();
    ignoredAttributes = {
      parent: true,
      id: true,
      name: true,
      "extends": true,
      type: true,
      scriptincludes: true
    };

    /**
     * @aside guide constraints
     * @class dr.view
     * @extends dr.node
     * The visual base class for everything in dreem. Views extend dr.node to add the ability to set and animate visual attributes, and interact with the mouse.
     *
     * Views are positioned inside their parent according to their x and y coordinates.
     *
     * Views can contain methods, handlers, setters, constraints, attributes and other view, node or class instances.
     *
     * Views can be easily converted to reusable classes/tags by changing their outermost &lt;view> tags to &lt;class> and adding a name attribute.
     *
     * Views support a number of builtin attributes. Setting attributes that aren't listed explicitly will pass through to the underlying Sprite implementation.
     *
     * Views currently integrate with jQuery, so any changes made to their CSS via jQuery will automatically cause them to update.
     *
     * Note that dreem apps must be contained inside a top-level &lt;view>&lt;/view> tag.
     *
     * The following example shows a pink view that contains a smaller blue view offset 10 pixels from the top and 10 from the left.
     *
     *     @example
     *     <view width="200" height="100" bgcolor="lightpink">
     *
     *       <view width="50" height="50" x="10" y="10" bgcolor="lightblue"></view>
     *
     *     </view>
     *
     * Here the blue view is wider than its parent pink view, and because the clip attribute of the parent is set to false it extends beyond the parents bounds.
     *
     *     @example
     *     <view width="200" height="100" bgcolor="lightpink" clip="false">
     *
     *       <view width="250" height="50" x="10" y="10" bgcolor="lightblue"></view>
     *
     *     </view>
     *
     * Now we set the clip attribute on the parent view to true, causing the overflowing child view to be clipped at its parent's boundary.
     *
     *     @example
     *     <view width="200" height="100" bgcolor="lightpink" clip="true">
     *
     *       <view width="250" height="50" x="10" y="10" bgcolor="lightblue"></view>
     *
     *     </view>
     *
     * Here we demonstrate how unsupported attributes are passed to the underlying sprite system. We make the child view semi-transparent by setting opacity. Although this is not in the list of supported attributes it is still applied.
     *
     *     @example
     *     <view width="200" height="100" bgcolor="lightpink">
     *
     *       <view width="250" height="50" x="10" y="10" bgcolor="lightblue" opacity=".5"></view>
     *
     *     </view>
     *
     * It is convenient to [constrain](#!/guide/constraints) a view's size and position to attributes of its parent view. Here we'll position the inner view so that its inset by 10 pixels in its parent.
     *
     *     @example
     *     <view width="200" height="100" bgcolor="lightpink">
     *
     *       <view width="${this.parent.width-this.inset*2}" height="${this.parent.height-this.inset*2}" x="${this.inset}" y="${this.inset}" bgcolor="lightblue">
     *         <attribute name="inset" type="number" value="10"></attribute>
     *       </view>
     *
     *     </view>
     */
    View = (function(_super) {
      __extends(View, _super);


      /**
       * @cfg {Number} [x=0]
       * This view's x position
       */


      /**
       * @cfg {Number} [y=0]
       * This view's y position
       */


      /**
       * @cfg {Number} [width=0]
       * This view's width
       */


      /**
       * @cfg {Number} [height=0]
       * This view's height
       */


      /**
       * @cfg {Boolean} [clickable=false]
       * If true, this view recieves mouse events. Automatically set to true when an onclick/mouse* event is registered for this view.
       */


      /**
       * @cfg {Boolean} [clip=false]
       * If true, this view clips to its bounds
       */


      /**
       * @cfg {Boolean} [scrollable=false]
       * If true, this view clips to its bounds and provides scrolling to see content that overflows the bounds
       */


      /**
       * @cfg {Boolean} [visible=true]
       * If false, this view is invisible
       */


      /**
       * @cfg {String} bgcolor
       * Sets this view's background color
       */


      /**
       * @event onclick
       * Fired when this view is clicked
       * @param {dr.view} view The dr.view that fired the event
       */


      /**
       * @event onmouseover
       * Fired when the mouse moves over this view
       * @param {dr.view} view The dr.view that fired the event
       */


      /**
       * @event onmouseout
       * Fired when the mouse moves off this view
       * @param {dr.view} view The dr.view that fired the event
       */


      /**
       * @event onmousedown
       * Fired when the mouse goes down on this view
       * @param {dr.view} view The dr.view that fired the event
       */


      /**
       * @event onmouseup
       * Fired when the mouse goes up on this view
       * @param {dr.view} view The dr.view that fired the event
       */

      function View(el, attributes) {
        var defaults, key, type, types, _ref;
        if (attributes == null) {
          attributes = {};
        }

        /**
         * @property {dr.view[]} subviews
         * @readonly
         * An array of this views's child views
         */

        /**
         * @event onsubviews
         * Fired when this views's subviews array has changed
         * @param {dr.view} view The dr.view that fired the event
         */

        /**
         * @property {dr.layout[]} layouts
         * @readonly
         * An array of this views's layouts. Only defined when needed.
         */

        /**
         * @event onlayouts
         * Fired when this views's layouts array has changed
         * @param {dr.layout} view The dr.layout that fired the event
         */

        /**
         * @property {Boolean} ignorelayout
         * If true, layouts should ignore this view
         */
        this.subviews = [];
        types = {
          x: 'number',
          y: 'number',
          width: 'number',
          height: 'number',
          clickable: 'boolean',
          clip: 'boolean',
          scrollable: 'boolean',
          visible: 'boolean'
        };
        defaults = {
          x: 0,
          y: 0,
          width: 0,
          height: 0,
          clickable: false,
          clip: false,
          scrollable: false,
          visible: true
        };
        _ref = attributes.$types;
        for (key in _ref) {
          type = _ref[key];
          types[key] = type;
        }
        attributes.$types = types;
        if (this._isPercent(attributes['width'])) {
          attributes['width'] = this._sizeFromPercent(attributes['width'], "width");
        }
        if (this._isPercent(attributes['height'])) {
          attributes['height'] = this._sizeFromPercent(attributes['height'], "height");
        }
        this._setDefaults(attributes, defaults);
        if (el instanceof View) {
          el = el.sprite;
        }
        this._createSprite(el, attributes);
        View.__super__.constructor.apply(this, arguments);
      }

      View.prototype._isPercent = function(value) {
        return typeof value === 'string' && value.indexOf('%') > -1;
      };

      View.prototype._sizeFromPercent = function(percent, dim) {
        return "${this.parent." + dim + " ? this.parent." + dim + "*" + (parseFloat(percent) / 100.0) + " : $(this.parent)." + dim + "()}";
      };

      View.prototype._createSprite = function(el, attributes) {
        return this.sprite = new Sprite(el, this, attributes.$tagname);
      };

      View.prototype.setAttribute = function(name, value, skipstyle) {
        value = this._coerceType(name, value);
        if (!(skipstyle || name in ignoredAttributes || this[name] === value)) {
          this.sprite.setStyle(name, value);
        }
        return View.__super__.setAttribute.call(this, name, value, true);
      };

      View.prototype.set_clickable = function(clickable) {
        return this.sprite.set_clickable(clickable);
      };

      View.prototype.set_parent = function(parent) {
        View.__super__.set_parent.apply(this, arguments);
        if (parent instanceof View) {
          parent.subviews.push(this);
          parent.sendEvent('subviews', this);
          parent = parent.sprite;
        }
        return this.sprite.set_parent(parent);
      };

      View.prototype.set_id = function(id) {
        View.__super__.set_id.apply(this, arguments);
        return this.sprite.set_id(id);
      };


      /**
       * Animates this view's attribute(s)
       * @param {Object} obj A hash of attribute names and values to animate to
       * @param Number duration The duration of the animation in milliseconds
       */

      View.prototype.animate = function() {
        this.sprite.animate.apply(this, arguments);
        return this;
      };

      View.prototype.set_clip = function(clip) {
        return this.sprite.set_clip(clip);
      };

      View.prototype.set_scrollable = function(scrollable) {
        return this.sprite.set_scrollable(scrollable);
      };

      View.prototype.destroy = function(skipevents) {
        View.__super__.destroy.apply(this, arguments);
        if (!skipevents) {
          this._removeFromParent('subviews');
        }
        this.sprite.destroy();
        return this.sprite = null;
      };

      View.prototype.getAbsolute = function() {
        return this.sprite.getAbsolute();
      };

      View.prototype.set_class = function(classname) {
        return this.sprite.set_class(classname);
      };

      return View;

    })(Node);

    /**
     * @class dr.inputtext
     * @extends dr.view
     * Provides an editable input text field.
     *
     *     @example
     *     <simplelayout axis="y"></simplelayout>
     *
     *     <text text="Enter your name"></text>
     *
     *     <inputtext id="nameinput" bgcolor="white" border="1px solid lightgrey" width="200"></inputtext>
     *
     *     <labelbutton text="submit">
     *       <handler event="onclick">
     *         welcome.setAttribute('text', 'Welcome ' + nameinput.text);
     *       </handler>
     *     </labelbutton>
     *
     *     <text id="welcome"></text>
     *
     * It's possible to listen for an onchange event to find out when the user changed the inputtext value:
     *
     *     @example
     *     <inputtext id="nameinput" bgcolor="white" border="1px solid lightgrey" width="200" onchange="console.log('onchange', this.text)"></inputtext>
     *
     */
    InputText = (function(_super) {
      __extends(InputText, _super);


      /**
       * @cfg {Boolean} [multiline=false]
       * Set to true to show multi-line text.
       */


      /**
       * @cfg {String} text
       * The text inside this input text field
       */


      /**
       * @cfg {Number} [width=100]
       * The width of this input text field
       */

      function InputText(el, attributes) {
        var defaults, key, type, types, _ref;
        if (attributes == null) {
          attributes = {};
        }
        types = {
          multiline: 'boolean'
        };
        defaults = {
          clickable: true,
          multiline: false,
          width: 100
        };
        _ref = attributes.$types;
        for (key in _ref) {
          type = _ref[key];
          types[key] = type;
        }
        attributes.$types = types;
        this._setDefaults(attributes, defaults);
        InputText.__super__.constructor.apply(this, arguments);
        if (!this.height) {
          this.setAttribute('height', this.sprite.getInputtextHeight());
        }
        this.listenTo(this, 'change', this._handleChange);
        this.listenTo(this, 'width', function(w) {
          return this.sprite.setStyle('width', w, true, this.sprite.input);
        });
        this.listenTo(this, 'height', function(h) {
          return this.sprite.setStyle('height', h, true, this.sprite.input);
        });
      }

      InputText.prototype._createSprite = function(el, attributes) {
        InputText.__super__._createSprite.apply(this, arguments);
        attributes.text || (attributes.text = this.sprite.getText(true));
        this.sprite.setText('');
        return this.sprite.createInputtextElement('', attributes.multiline, attributes.width, attributes.height);
      };

      InputText.prototype._handleChange = function() {
        var newdata;
        if (!this.replicator) {
          return;
        }
        newdata = this.text;
        if (typeof this.data === 'number') {
          if (parseFloat(newdata) + '' === newdata) {
            newdata = parseFloat(newdata);
          }
        } else if (typeof this.data === 'boolean') {
          if (newdata === 'true') {
            newdata = true;
          } else if (newdata === 'false') {
            newdata = false;
          }
        }
        return this.replicator.updateData(newdata);
      };

      InputText.prototype.set_data = function(d) {
        return this.setAttribute('text', d, true);
      };

      InputText.prototype.set_text = function(text) {
        return this.sprite.value(text);
      };

      return InputText;

    })(View);

    /**
     * @class dr.text
     * @extends dr.view
     * Text component that supports single and multi-line text.
     *
     * The text component can be fixed size, or sized to fit the size of the text.
     *
     *     @example
     *     <text text="Hello World!" bgcolor="red"></text>
     *
     * Here is a multiline text
     *
     *     @example
     *     <text multiline="true" text="Lorem ipsum dolor sit amet, consectetur adipiscing elit"></text>
     *
     * You might want to set the value of a text element based on the value of other attributes via a constraint. Here we set the value by concatenating three attributes together.
     *
     *     @example
     *     <attribute name="firstName" type="string" value="Lumpy"></attribute>
     *     <attribute name="middleName" type="string" value="Space"></attribute>
     *     <attribute name="lastName" type="string" value="Princess"></attribute>
     *
     *     <text text="${this.parent.firstName + ' ' + this.parent.middleName + ' ' + this.parent.lastName}" color="hotpink"></text>
     *
     * Constraints can contain more complex JavaScript code
     *
     *     @example
     *     <attribute name="firstName" type="string" value="Lumpy"></attribute>
     *     <attribute name="middleName" type="string" value="Space"></attribute>
     *     <attribute name="lastName" type="string" value="Princess"></attribute>
     *
     *     <text text="${this.parent.firstName.charAt(0) + ' ' + this.parent.middleName.charAt(0) + ' ' + this.parent.lastName.charAt(0)}" color="hotpink"></text>
     *
     * We can simplify this by using a method to return the concatenation and constraining the text value to the return value of the method
     *
     *     @example
     *     <attribute name="firstName" type="string" value="Lumpy"></attribute>
     *     <attribute name="middleName" type="string" value="Space"></attribute>
     *     <attribute name="lastName" type="string" value="Princess"></attribute>
     *
     *     <method name="initials">
     *       return this.firstName.charAt(0) + ' ' + this.middleName.charAt(0) + ' ' + this.lastName.charAt(0);
     *     </method>
     *
     *     <text text="${this.parent.initials()}" color="hotpink"></text>
     *
     * You can override the format method to provide custom formatting for text elements. Here is a subclass of text, timetext, with the format method overridden to convert the text given in seconds into a formatted string.
     *
     *     @example
     *     <class name="timetext" extends="text">
     *       <method name="format" args="seconds">
     *         var minutes = Math.floor(seconds / 60);
     *         var seconds = Math.floor(seconds) - minutes * 60;
     *         if (seconds < 10) {
     *           seconds = '0' + seconds;
     *         }
     *         return minutes + ':' + seconds;
     *       </method>
     *     </class>
     *
     *     <timetext text="240"></timetext>
     *
     */
    Text = (function(_super) {
      __extends(Text, _super);


      /**
       * @cfg {Boolean} [multiline=false]
       * Set to true to show multi-line text.
       */


      /**
       * @cfg {Boolean} [resize=true]
       * By default, the text component is sized to the size of the text.
       * By setting resize=false, the component size is not modified
       * when the text changes.
       */


      /**
       * @cfg {String} [text=""]
       * Component text.
       */

      function Text(el, attributes) {
        var defaults, key, type, types, _ref;
        if (attributes == null) {
          attributes = {};
        }
        types = {
          resize: 'boolean',
          multiline: 'boolean'
        };
        defaults = {
          resize: true,
          multiline: false
        };
        _ref = attributes.$types;
        for (key in _ref) {
          type = _ref[key];
          types[key] = type;
        }
        attributes.$types = types;
        this._setDefaults(attributes, defaults);
        if ('width' in attributes) {
          this._initialwidth = attributes.width;
        }
        this.listenTo(this, 'multiline', this.updateSize);
        this.listenTo(this, 'resize', this.updateSize);
        this.listenTo(this, 'init', this.updateSize);
        Text.__super__.constructor.apply(this, arguments);
      }

      Text.prototype._createSprite = function(el, attributes) {
        Text.__super__._createSprite.apply(this, arguments);
        attributes.text || (attributes.text = this.sprite.getText(true));
        return this.sprite.createTextElement();
      };


      /**
       * @method format
       * Format the text to be displayed. The default behavior is to
       * return the text intact. Override to change formatting.
       * @param {String} str The current value of the text component.
       * @return {String} The formated string to display in the component.
       *
       */

      Text.prototype.format = function(str) {
        return str;
      };

      Text.prototype.updateSize = function() {
        var parent, parents, size, width, _i, _j, _len, _len1;
        if (!this.inited) {
          return;
        }
        width = this.multiline ? this._initialwidth : this.width;
        size = this.sprite.measureTextSize(this.multiline, width, this.resize);
        if (size.width === 0 && size.height === 0) {
          parents = this._findParents('visible', false);
          for (_i = 0, _len = parents.length; _i < _len; _i++) {
            parent = parents[_i];
            parent.sprite.el.style.display = '';
          }
          size = this.sprite.measureTextSize(this.multiline, width, this.resize);
          for (_j = 0, _len1 = parents.length; _j < _len1; _j++) {
            parent = parents[_j];
            parent.sprite.el.style.display = 'none';
          }
        }
        this.setAttribute('width', size.width, true);
        return this.setAttribute('height', size.height, true);
      };

      Text.prototype.set_data = function(d) {
        return this.setAttribute('text', d, true);
      };

      Text.prototype.set_text = function(text) {
        if (text !== this.text) {
          this.sprite.setText(this.format(text));
          return this.updateSize();
        }
      };

      return Text;

    })(View);
    warnings = [];
    showWarnings = function(data) {
      var out, pre;
      warnings = warnings.concat(data);
      out = data.join('\n');
      pre = document.createElement('pre');
      pre.setAttribute('class', 'warnings');
      pre.textContent = out;
      document.body.insertBefore(pre, document.body.firstChild);
      return console.error(out);
    };
    dom = (function() {
      var builtinTags, checkRequiredAttributes, exports, findAutoIncludes, flattenattributes, getChildren, htmlDecode, initAllElements, initElement, initFromElement, processSpecialTags, requiredAttributes, sendInit, specialtags, writeCSS;
      getChildren = function(el) {
        var child, _i, _len, _ref, _ref1, _results;
        _ref = el.childNodes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.nodeType === 1 && (_ref1 = child.localName, __indexOf.call(specialtags, _ref1) >= 0)) {
            _results.push(child);
          }
        }
        return _results;
      };
      flattenattributes = function(namednodemap) {
        var attributes, i, _i, _len;
        attributes = {};
        for (_i = 0, _len = namednodemap.length; _i < _len; _i++) {
          i = namednodemap[_i];
          attributes[i.name] = i.value;
        }
        return attributes;
      };
      sendInit = function() {
        var event;
        event = document.createEvent('Event');
        event.initEvent('dreeminit', true, true);
        return window.dispatchEvent(event);
      };
      initFromElement = function(el) {
        el.style.display = 'none';
        return findAutoIncludes(el, function() {
          el.style.display = null;
          initElement(el);
          _initConstraints();
          window.DREEM_INITED = true;
          return sendInit();
        });
      };
      findAutoIncludes = function(parentel, callback) {
        var cb, cb2, fileloaded, filerequests, includedScripts, includerequests, inlineclasses, jqel, loadIncludes, loadLZX, loadScript, loadqueue, scriptloading, validator;
        jqel = $(parentel);
        includerequests = [];
        includedScripts = {};
        loadqueue = [];
        scriptloading = false;
        loadScript = function(url, cb, error) {
          var appendScript, appendcallback;
          if (url in includedScripts) {
            return;
          }
          includedScripts[url] = true;
          if (scriptloading) {
            loadqueue.push(url, error);
            return url;
          }
          appendScript = function(url, cb, error) {
            var script;
            if (error == null) {
              error = 'failed to load scriptinclude ' + url;
            }
            scriptloading = url;
            script = document.createElement('script');
            script.type = 'text/javascript';
            $('head').append(script);
            script.onload = cb;
            script.onerror = function() {
              console.error(error);
              return cb();
            };
            return script.src = url;
          };
          appendcallback = function() {
            scriptloading = false;
            if (loadqueue.length === 0) {
              return cb();
            } else {
              return appendScript(loadqueue.shift(), appendcallback, loadqueue.shift());
            }
          };
          return appendScript(url, appendcallback, error);
        };
        inlineclasses = {};
        filerequests = [];
        fileloaded = {};
        loadLZX = function(name, el) {
          var prom, url, _ref;
          if (name in dr || name in fileloaded || __indexOf.call(specialtags, name) >= 0 || name in inlineclasses || __indexOf.call(builtinTags, name) >= 0) {
            return;
          }
          if (_ref = el.parentNode.localName, __indexOf.call(specialtags, _ref) >= 0) {
            return;
          }
          fileloaded[name] = true;
          url = '/classes/' + name + '.dre';
          prom = $.get(url);
          prom.url = url;
          prom.el = el;
          return filerequests.push(prom);
        };
        loadIncludes = function(callback) {
          var jel, url, _i, _len, _ref;
          _ref = jqel.find('include');
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            jel = _ref[_i];
            url = jel.attributes.href.value;
            jel.parentNode.removeChild(jel);
            if (!fileloaded[url]) {
              fileloaded[url] = true;
              includerequests.push($.get(url));
            }
          }
          return $.when.apply($, includerequests).done(function() {
            var args, el, extendz, html, includeRE, initONE, name, xhr, _j, _k, _len1, _len2, _ref1;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            if (includerequests.length === 1) {
              args = [args];
            }
            includerequests = [];
            includeRE = /<[\/]*library>/gi;
            initONE = true;
            for (_j = 0, _len1 = args.length; _j < _len1; _j++) {
              xhr = args[_j];
              html = xhr[0].replace(includeRE, '');
              jqel.prepend(html);
            }
            _ref1 = jqel.find('*');
            for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
              el = _ref1[_k];
              name = el.localName;
              if (name === 'class') {
                if (el.attributes["extends"]) {
                  extendz = el.attributes["extends"].value;
                  loadLZX(extendz, el);
                }
                inlineclasses[el.attributes.name.value] = true;
              } else if (name === 'state') {
                initONE = true;
              } else if (name === 'replicator') {
                loadLZX(name, el);
                loadLZX(el.attributes.classname.value, el);
              } else {
                loadLZX(name, el);
              }
            }
            return $.when.apply($, filerequests).done(function() {
              var args, scriptsloading, _l, _len3, _len4, _len5, _m, _n, _ref2, _ref3, _ref4;
              args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              if (filerequests.length === 1) {
                args = [args];
              }
              for (_l = 0, _len3 = args.length; _l < _len3; _l++) {
                xhr = args[_l];
                jqel.prepend(xhr[0]);
                if (debug) {
                  jqel.contents().each(function() {
                    if (this.nodeType === 8) {
                      return $(this).remove();
                    }
                  });
                }
              }
              scriptsloading = false;
              if (initONE) {
                scriptsloading = loadScript('/lib/one_base.js', function() {
                  ONE.base_.call(Eventable.prototype);
                  Eventable.prototype.enumfalse(Eventable.prototype.keys());
                  Node.prototype.enumfalse(Node.prototype.keys());
                  View.prototype.enumfalse(View.prototype.keys());
                  Layout.prototype.enumfalse(Layout.prototype.keys());
                  return callback();
                });
              }
              _ref2 = jqel.find('[scriptincludes]');
              for (_m = 0, _len4 = _ref2.length; _m < _len4; _m++) {
                el = _ref2[_m];
                _ref3 = el.attributes.scriptincludes.value.split(',');
                for (_n = 0, _len5 = _ref3.length; _n < _len5; _n++) {
                  url = _ref3[_n];
                  scriptsloading = loadScript(url.trim(), callback, (_ref4 = el.attributes.scriptincludeserror) != null ? _ref4.value.toString() : void 0);
                }
              }
              filerequests = [];
              if (!scriptsloading) {
                return callback();
              }
            }).fail(function() {
              var args, _l, _len3;
              args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              if (args.length === 1) {
                args = [args];
              }
              for (_l = 0, _len3 = args.length; _l < _len3; _l++) {
                xhr = args[_l];
                showWarnings(["failed to load " + xhr.url + " for element " + xhr.el.outerHTML]);
              }
            });
          });
        };
        validator = function() {
          var prom, url;
          url = '/validate/';
          prom = $.ajax({
            url: url,
            data: {
              url: window.location.pathname
            },
            success: function(data) {
              if (data.length) {
                return showWarnings(data);
              }
            }
          });
          return callback();
        };
        cb2 = function() {
          return loadIncludes(validator);
        };
        cb = function() {
          return loadIncludes(cb2);
        };
        return loadIncludes(cb);
      };
      specialtags = ['handler', 'method', 'attribute', 'setter', 'include'];
      builtinTags = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'command', 'datalist', 'dd', 'del', 'details', 'dfn', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'image', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'map', 'mark', 'menu', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr'];
      requiredAttributes = {
        "class": {
          "name": 1
        },
        "method": {
          "name": 1
        },
        "setter": {
          "name": 1
        },
        "handler": {
          "event": 1
        },
        "attribute": {
          "name": 1,
          "type": 1,
          "value": 1
        },
        "dataset": {
          "name": 1
        },
        "replicator": {
          "classname": 1
        }
      };
      checkRequiredAttributes = function(tagname, attributes, tag, parenttag) {
        var attrname, error;
        if (tagname in requiredAttributes) {
          for (attrname in requiredAttributes[tagname]) {
            if (!(attrname in attributes)) {
              error = "" + tagname + "." + attrname + " must be defined on " + tag.outerHTML;
              if (parenttag) {
                error = error + (" inside " + parenttag.outerHTML);
              }
              showWarnings([error]);
            }
          }
        }
        return error;
      };
      initElement = function(el, parent) {
        var attr, attributes, checkChildren, child, children, event, eventname, isClass, isState, li, skiponinit, tagname, _i, _j, _len, _len1;
        if (el.$init) {
          return;
        }
        el.$init = true;
        tagname = el.localName;
        if (__indexOf.call(specialtags, tagname) >= 0) {
          return;
        }
        if (!tagname in dr) {
          if (__indexOf.call(builtinTags, tagname) < 0) {
            console.warn('could not find class for tag', tagname, el);
          }
          return;
        } else if (__indexOf.call(builtinTags, tagname) >= 0) {
          if (tagname !== 'input') {
            console.warn('refusing to create a class that would overwrite the builtin tag', tagname);
          }
          return;
        }
        attributes = flattenattributes(el.attributes);
        checkRequiredAttributes(tagname, attributes, el);
        attributes.$tagname = tagname;
        for (_i = 0, _len = mouseEvents.length; _i < _len; _i++) {
          event = mouseEvents[_i];
          eventname = 'on' + event;
          if (eventname in attributes) {
            if (attributes.clickable !== false) {
              attributes.clickable = true;
            }
            el.removeAttribute(eventname);
          }
        }
        for (attr in attributes) {
          if (attr.indexOf('on') === 0) {
            el.removeAttribute(attr);
          }
        }
        if (parent == null) {
          parent = el.parentNode;
        }
        if (parent != null) {
          attributes.parent = parent;
        }
        li = tagname.lastIndexOf('state');
        isState = li > -1 && li === tagname.length - 5;
        isClass = tagname === 'class';
        if (!(isClass || isState)) {
          dom.processSpecialTags(el, attributes, attributes.type);
        }
        children = (function() {
          var _j, _len1, _ref, _results;
          _ref = el.childNodes;
          _results = [];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            child = _ref[_j];
            if (child.nodeType === 1) {
              _results.push(child);
            }
          }
          return _results;
        })();
        attributes.$skiponinit = skiponinit = children.length > 0;
        if (typeof dr[tagname] === 'function') {
          parent = new dr[tagname](el, attributes);
        } else {
          showWarnings(["Unrecognized class " + tagname + " " + el.outerHTML]);
          return;
        }
        if (!(children.length > 0)) {
          return;
        }
        if (!(isClass || isState)) {
          children = (function() {
            var _j, _len1, _ref, _results;
            _ref = el.childNodes;
            _results = [];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              child = _ref[_j];
              if (child.nodeType === 1) {
                _results.push(child);
              }
            }
            return _results;
          })();
          for (_j = 0, _len1 = children.length; _j < _len1; _j++) {
            child = children[_j];
            initElement(child, parent);
          }
          if (!parent.inited) {
            checkChildren = function() {
              var _k, _len2;
              for (_k = 0, _len2 = children.length; _k < _len2; _k++) {
                child = children[_k];
                if (!child.inited && child.localName === !'class') {
                  setTimeout(checkChildren, 0);
                  return;
                }
              }
              parent.inited = true;
              parent.sendEvent('init', parent);
            };
            setTimeout(checkChildren, 0);
          }
        }
      };
      writeCSS = function() {
        var style;
        style = document.createElement('style');
        style.type = 'text/css';
        style.innerHTML = '.sprite{ position: absolute; pointer-events: none; padding: 0; margin: 0; box-sizing:border-box;} .sprite-text{ width: auto; height; auto; white-space: nowrap;  padding: 0; margin: 0;} .sprite-inputtext{border: none; outline: none; background-color:transparent; resize:none;} .hidden{ display: none; } .noselect{ -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;} method { display: none; } handler { display: none; } setter { display: none; } class { display:none } node { display:none } dataset { display:none } .warnings {font-size: 14px; background-color: pink; margin: 0;}';
        return document.getElementsByTagName('head')[0].appendChild(style);
      };
      initAllElements = function(selector) {
        var el, _i, _len;
        if (selector == null) {
          selector = $('view').not('view view');
        }
        for (_i = 0, _len = selector.length; _i < _len; _i++) {
          el = selector[_i];
          initFromElement(el);
        }
      };
      htmlDecode = function(input) {
        var child, e, out, _i, _len, _ref;
        e = document.createElement('div');
        e.innerHTML = input;
        out = '';
        _ref = e.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if ((child.nodeValue != null) && (child.nodeType === 3 || child.nodeType === 8)) {
            out += child.nodeValue;
          } else {
            return;
          }
        }
        return out;
      };
      processSpecialTags = function(el, classattributes, defaulttype) {
        var args, attributes, child, children, handler, name, script, tagname, type, _base, _base1, _i, _len, _name, _ref, _ref1;
        if (classattributes.$types == null) {
          classattributes.$types = {};
        }
        if (classattributes.$methods == null) {
          classattributes.$methods = {};
        }
        if (classattributes.$handlers == null) {
          classattributes.$handlers = [];
        }
        children = getChildren(el);
        for (_i = 0, _len = children.length; _i < _len; _i++) {
          child = children[_i];
          attributes = flattenattributes(child.attributes);
          tagname = child.localName;
          args = ((_ref = attributes.args) != null ? _ref : '').split();
          script = htmlDecode(child.innerHTML);
          if (script == null) {
            console.warn('Invalid tag', name, child);
          }
          type = (_ref1 = attributes.type) != null ? _ref1 : defaulttype;
          name = attributes.name;
          checkRequiredAttributes(tagname, attributes, child, el);
          switch (tagname) {
            case 'handler':
              handler = {
                name: name,
                ev: attributes.event,
                script: compiler.transform(script, type),
                args: args,
                reference: attributes.reference,
                method: attributes.method
              };
              classattributes.$handlers.push(handler);
              break;
            case 'method':
              if ((_base = classattributes.$methods)[name] == null) {
                _base[name] = [];
              }
              classattributes.$methods[name].push({
                method: compiler.transform(script, type),
                args: args,
                allocation: attributes.allocation
              });
              break;
            case 'setter':
              if ((_base1 = classattributes.$methods)[_name = 'set_' + name] == null) {
                _base1[_name] = [];
              }
              classattributes.$methods['set_' + name].push({
                method: compiler.transform(script, type),
                args: args,
                allocation: attributes.allocation
              });
              break;
            case 'attribute':
              classattributes[name] = attributes.value;
              classattributes.$types[name] = attributes.type;
          }
        }
        return children;
      };
      return exports = {
        initAllElements: initAllElements,
        initElement: initElement,
        processSpecialTags: processSpecialTags,
        writeCSS: writeCSS
      };

      /**
         * @class dr.state
         * @extends dr.node
         * Allows a group of attributes, methods, handlers and instances to be removed and applied as a group.
         * 
         * Like views and nodes, states can contain methods, handlers, setters, constraints, attributes and other view, node or class instances.
         *
         * Currently, states must end with the string 'state' in their name to work properly.
         *
         *     @example
         *     <simplelayout axis="y"></simplelayout>
         *     <view id="square" width="100" height="100" bgcolor="lightgrey">
         *       <attribute name="ispink" type="boolean" value="false"></attribute>
         *       <state name="pinkstate" applied="${this.parent.ispink}">
         *         <attribute name="bgcolor" value="pink" type="string"></attribute>
         *       </state>
         *     </view>
         *     <labelbutton text="pinkify!">
         *       <handler event="onclick">
         *         square.setAttribute('ispink', true);
         *       </handler>
         *     </labelbutton>
         *
       */
    })();
    State = (function(_super) {
      __extends(State, _super);

      function State(el, attributes) {
        var child, compilertype, handler, instancebody, name, oldbody, processedChildren, value, _i, _j, _len, _len1, _ref, _ref1;
        if (attributes == null) {
          attributes = {};
        }
        this.skipattributes = ['parent', 'types', 'applyattributes', 'applied', 'skipattributes', 'stateattributes'];
        this.stateattributes = attributes;
        this.applyattributes = {};
        this.applied = false;
        compilertype = attributes.type;
        processedChildren = dom.processSpecialTags(el, attributes, compilertype);
        oldbody = el.innerHTML.trim();
        for (_i = 0, _len = processedChildren.length; _i < _len; _i++) {
          child = processedChildren[_i];
          child.parentNode.removeChild(child);
        }
        instancebody = el.innerHTML.trim();
        if (oldbody) {
          el.innerHTML = oldbody;
        }
        this.types = (_ref = attributes.$types) != null ? _ref : {};
        this.setAttribute('parent', attributes.parent);
        this.installMethods(attributes.$methods, this.parent.$tagname, this, this.parent);
        if (attributes.name) {
          this.setAttribute('name', attributes.name);
          this.skipattributes.push('name');
        }
        if (attributes.applied) {
          this.bindAttribute('applied', attributes.applied, 'state');
        }
        _ref1 = attributes.$handlers;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          handler = _ref1[_j];
          if (handler.ev === 'onapplied') {
            this.installHandlers([handler], 'state', this);
            this._bindHandlers();
          }
        }
        for (name in attributes) {
          value = attributes[name];
          if (!(__indexOf.call(this.skipattributes, name) >= 0 || name.charAt(0) === '$')) {
            this.applyattributes[name] = value;
            this.setAttribute(name, value);
          }
        }
        if (this.constraints) {
          this._bindConstraints();
          this.skipattributes.push('constraints');
        }
        if (this.events) {
          this.skipattributes.push('events');
        }
        if (this.handlers) {
          this.skipattributes.push('handlers');
        }
        if (this.latehandlers) {
          this.skipattributes.push('latehandlers');
        }
        this.enumfalse(this.skipattributes);
        this.enumfalse(this.keys);
      }


      /**
       * @event onapplied 
       * Fired when the state has been applied or unapplied. Onapplied handlers run in the scope of the state itself, see dragstate for an example.
       * @param {Boolean} applied If true, the state was applied.
       */


      /**
       * @cfg {Boolean} [applied=false]
       * If true, the state is applied.
       */

      State.prototype.set_applied = function(applied) {
        var name, parentname, val;
        if (!this.parent) {
          return;
        }
        if (this.applied === applied) {
          return;
        }
        this.applied = applied;
        if (applied) {
          this.parent.learn(this);
          if (this.stateattributes.$handlers) {
            this.parent.installHandlers(this.stateattributes.$handlers, this.parent.$tagname, this.parent);
            this.parent._bindHandlers();
            this.parent._bindHandlers(true);
          }
        } else {
          this.parent.forget(this);
          if (this.stateattributes.$handlers) {
            this.parent.removeHandlers(this.stateattributes.$handlers, this.parent.$tagname, this.parent);
          }
        }
        parentname = this.parent.$tagname;
        for (name in this.applyattributes) {
          val = this.parent[name];
          if (val === void 0) {
            continue;
          }
          this.parent[name] = !val;
          this.parent.bindAttribute(name, val, parentname);
        }
      };

      State.prototype.apply = function() {
        if (!this.applied) {
          return this.setAttribute('applied', true);
        }
      };

      State.prototype.remove = function() {
        if (this.applied) {
          return this.setAttribute('applied', false);
        }
      };

      return State;

    })(Node);

    /**
     * @class dr.class
     * Allows new tags to be created. Classes only be created with the &lt;class>&lt;/class> tag syntax. 
     * 
     * Classes can extend any other class, and they extend dr.view by default. 
     * 
     * Once declared, classes invoked with the declarative syntax, e.g. &lt;classname>&lt;/classname>.
     * 
     * If a class can't be found in the document, dreem will automatically attempt to load it from the classes/* directory.
     *
     * Like views and nodes, classes can contain methods, handlers, setters, constraints, attributes and other view, node or class instances.
     *
     * Here is a class called 'tile' that extends dr.view. It sets the bgcolor, width, and height attributes. An instance of tile is created using declarative syntax.
     *
     *     @example
     *     <class name="tile" extends="view" bgcolor="thistle" width="100" height="100"></class>
     *
     *     <tile></tile>
     *
     * Now we'll extend the tile class with a class called 'labeltile', which contains a label inside of the box. We'll declare one each of tile and labeltile, and position them with a simplelayout.
     *
     *     @example
     *     <class name="tile" extends="view" bgcolor="thistle" width="100" height="100"></class>
     *
     *     <class name="labeltile" extends="tile">
     *       <text text="Tile"></text>
     *     </class>
     *
     *     <simplelayout axis="x"></simplelayout>
     *     <tile></tile>
     *     <labeltile></labeltile>
     *
     * Attributes that are declared inside of a class definition can be set when the instance is declared. Here we bind the label text to the value of an attribute called label.
     *
     *     @example
     *     <class name="tile" extends="view" bgcolor="thistle" width="100" height="100"></class>
     *
     *     <class name="labeltile" extends="tile">
     *       <attribute name="label" type="string" value=""></attribute>
     *       <text text="${this.parent.label}"></text>
     *     </class>
     *
     *     <simplelayout axis="x"></simplelayout>
     *     <tile></tile>
     *     <labeltile label="The Tile"></labeltile>
     *
     */
    Class = (function() {

      /**
       * @cfg {String} name (required)
       * The name of the new tag.
       */

      /**
       * @cfg {String} [extends=view] 
       * The name of a class that should be extended.
       */

      /**
       * @cfg {"js"/"coffee"} [type=js] 
       * The default compiler to use for methods, setters and handlers. Either 'js' or 'coffee'
       */
      var clone;

      clone = function(obj) {
        var name, newobj, val;
        newobj = {};
        for (name in obj) {
          val = obj[name];
          newobj[name] = val;
        }
        return newobj;
      };

      function Class(el, classattributes) {
        var child, compilertype, extend, haschildren, ignored, instancebody, name, oldbody, processedChildren, _i, _len;
        if (classattributes == null) {
          classattributes = {};
        }
        name = classattributes.name;
        extend = classattributes["extends"] != null ? classattributes["extends"] : classattributes["extends"] = 'view';
        compilertype = classattributes.type;
        for (ignored in ignoredAttributes) {
          delete classattributes[ignored];
        }
        processedChildren = dom.processSpecialTags(el, classattributes, compilertype);
        oldbody = el.innerHTML.trim();
        for (_i = 0, _len = processedChildren.length; _i < _len; _i++) {
          child = processedChildren[_i];
          child.parentNode.removeChild(child);
        }
        haschildren = ((function() {
          var _j, _len1, _ref, _results;
          _ref = el.childNodes;
          _results = [];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            child = _ref[_j];
            if (child.nodeType === 1) {
              _results.push(child);
            }
          }
          return _results;
        })()).length > 0;
        instancebody = el.innerHTML.trim();
        if (oldbody) {
          el.innerHTML = oldbody;
        }
        if (name in dr) {
          console.warn('overwriting class', name);
        }
        dr[name] = function(instanceel, instanceattributes) {
          var attributes, checkChildren, children, key, parent, propname, sendInit, val, value, viewel, _j, _len1, _ref;
          attributes = clone(classattributes);
          for (key in instanceattributes) {
            value = instanceattributes[key];
            if ((key === '$methods' || key === '$types') && key in attributes) {
              attributes[key] = clone(attributes[key]);
              for (propname in value) {
                val = value[propname];
                if (key === '$methods' && attributes[key][propname]) {
                  attributes[key][propname] = attributes[key][propname].concat(val);
                } else {
                  attributes[key][propname] = val;
                }
              }
            } else if (key === '$handlers' && key in attributes) {
              attributes[key] = attributes[key].concat(value);
            } else {
              attributes[key] = value;
            }
          }
          if (!(extend in dr)) {
            console.warn('could not find class for tag', extend);
            return;
          }
          if (attributes.$tagname === 'class' || !attributes.$tagname) {
            attributes.$tagname = name;
          }
          attributes.$skiponinit = true;
          attributes.$deferbindings = haschildren;
          parent = new dr[extend](instanceel, attributes);
          viewel = (_ref = parent.sprite) != null ? _ref.el : void 0;
          if (instanceel) {
            if (!viewel) {
              instanceel.setAttribute('class', 'hidden');
            }
          }
          if (instancebody && viewel) {
            if (viewel.innerHTML) {
              viewel.innerHTML = instancebody + viewel.innerHTML;
            } else {
              viewel.innerHTML = instancebody;
            }
            children = (function() {
              var _j, _len1, _ref1, _results;
              _ref1 = viewel.childNodes;
              _results = [];
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                child = _ref1[_j];
                if (child.nodeType === 1) {
                  _results.push(child);
                }
              }
              return _results;
            })();
            for (_j = 0, _len1 = children.length; _j < _len1; _j++) {
              child = children[_j];
              dom.initElement(child, parent);
            }
          }
          sendInit = function() {
            if (parent.inited) {
              return;
            }
            parent._bindHandlers();
            parent._bindHandlers(true);
            parent.inited = true;
            return parent.sendEvent('init', parent);
          };
          if (children != null ? children.length : void 0) {
            checkChildren = function() {
              var _k, _len2;
              for (_k = 0, _len2 = children.length; _k < _len2; _k++) {
                child = children[_k];
                if (!child.inited && child.localName === !'class') {
                  setTimeout(checkChildren, 0);
                  return;
                }
              }
              return sendInit();
            };
            setTimeout(checkChildren, 0);
          } else {
            sendInit();
          }
          return parent;
        };
      }

      return Class;

    })();

    /**
     * @class dr.layout
     * @extends dr.node
     * The base class for all layouts. 
     *
     * When a new layout is added, it will automatically create and add itself to a layouts array in its parent. In addition, an onlayouts event is fired in the parent when the layouts array changes. This allows the parent to access the layout(s) later.
     *
     * Here is a view that contains both a simplelayout and a boundslayout.
     *
     *     @example
     *     <simplelayout axis="y"></simplelayout>
     *     <view bgcolor="oldlace">
     *       <boundslayout></boundslayout>
     *
     *       <simplelayout axis="x"></simplelayout>
     *
     *       <view width="50" height="50" bgcolor="lightpink" opacity=".3"></view>
     *       <view width="50" height="50" bgcolor="plum" opacity=".3"></view>
     *       <view width="50" height="50" bgcolor="lightblue" opacity=".3"></view>
     *
     *       <handler event="onlayouts" args="layouts">
     *         output.setAttribute('text', output.text||'' + "New layout added: " + layouts[layouts.length-1].$tagname + "\n");
     *       </handler>
     *     </view>
     *
     *     <text id="output" multiline="true" width="300"></text>
     *
     * Here we create diagonlayout, a subclass of layout that lays out the subviews in a diagonal formation. The update method sets the positions of the subview, and the onsubview handler attaches event listeners to the subviews as they are added so update is called if their dimensions or visibility are updated.
     *
     *     @example
     *     <class name="diagonlayout" extends="layout">
     *       <handler event="onsubview" args="subview">
     *         this.listenTo(subview, 'visible', this.update);
     *         this.listenTo(subview, 'width', this.update);
     *         this.listenTo(subview, 'height', this.update);
     *       </handler>
     *       <method name="update" args="value, sender">
     *         var posX = 0;
     *         var posY = 0;
     *         for (var i=0, l = this.parent.subviews.length; i < l; i++) {
     *           var subview = this.parent.subviews[i];
     *           if (subview.ignorelayout || !subview.visible) {
     *             continue;
     *           }
     *
     *           subview.setAttribute('x', posX);
     *           subview.setAttribute('y', posY);
     *
     *           posX += subview.width;
     *           posY += subview.height;
     *         }
     *       </method>
     *     </class>
     *
     *     <diagonlayout></diagonlayout>
     *     <view id="v1" width="50" height="50" bgcolor="Aqua"></view>
     *     <view id="v2" width="50" height="50" bgcolor="HotPink"></view>
     *     <view id="v3" width="50" height="50" bgcolor="MediumPurple"></view>
     *
     *     <labelbutton text="click me">
     *       <handler event="onclick">
     *         v1.setAttribute('width', 100);
     *         v2.setAttribute('height', 150);
     *       </handler>
     *     </labelbutton>
     *
     *
     */
    Layout = (function(_super) {
      __extends(Layout, _super);

      function Layout(el, attributes) {
        var subview, subviews, _base, _i, _len;
        if (attributes == null) {
          attributes = {};
        }
        this._added = __bind(this._added, this);
        this.locked = true;
        Layout.__super__.constructor.apply(this, arguments);
        this.listenTo(this.parent, 'subviews', this._added);
        this.listenTo(this.parent, 'init', this.update);
        if ((_base = this.parent).layouts == null) {
          _base.layouts = [];
        }
        this.parent.layouts.push(this);
        this.parent.sendEvent('layouts', this.parent.layouts);
        subviews = this.parent.subviews;
        if (subviews) {
          for (_i = 0, _len = subviews.length; _i < _len; _i++) {
            subview = subviews[_i];
            this._added(subview);
          }
        }
        this.locked = false;
        this.update();
      }

      Layout.prototype._added = function(child) {
        if (child) {

          /**
           * @event onsubview 
           * Fired when the layout has a new subview. Used to listen for events on the view that the layout cares about.
           * @param {dr.view} child The subview that was added
           */
          if (!child.ignorelayout) {
            this.sendEvent('subview', child);
          }
        }
        return this.update(null, child);
      };


      /**
       * @method update
       * @abstract
       * Called when the layout should be updated. Must be implemented to update the position of the subviews
       * @param value The value received from the node that updated
       * @param {dr.node} sender The node that updated
       */


      /**
       * Determines if a layout should be updated or not, usually called from update
       * @returns {Boolean} If true, skip updating the layout
       */

      Layout.prototype.skip = function() {
        var _ref;
        if (this.locked || (!this.inited) || (!((_ref = this.parent) != null ? _ref.subviews : void 0)) || (this.parent.subviews.length === 0)) {
          return true;
        }
      };

      Layout.prototype.destroy = function(skipevents) {
        this.locked = true;
        Layout.__super__.destroy.apply(this, arguments);
        if (!skipevents) {
          return this._removeFromParent('layouts');
        }
      };

      Layout.prototype.set_locked = function(locked) {
        var changed;
        changed = this.locked !== locked;

        /**
         * @property {Boolean} locked
         * If true, this layout will not update
         */
        this.locked = locked;

        /**
         * @event onlocked 
         * Fired when the layout is locked
         * @param {Boolean} locked If true, the layout is locked
         */
        this.sendEvent('locked', locked);
        if (changed && !locked) {
          return this.update();
        }
      };

      return Layout;

    })(Node);
    idle = (function() {
      var doTick, requestAnimationFrame, tickEvents, ticking;
      requestAnimationFrame = (function() {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
          return window.setTimeout(callback, 1000 / 60);
        };
      })();
      ticking = false;
      tickEvents = [];
      doTick = function(time) {
        var key;
        for (key in tickEvents) {
          if (tickEvents[key]) {
            tickEvents[key](time);
            tickEvents[key] = null;
          }
        }
        return ticking = false;
      };
      return function(key, callback) {
        if (!ticking) {
          requestAnimationFrame(doTick);
        }
        ticking = true;
        return tickEvents[key] = callback;
      };
    })();
    StartEventable = (function(_super) {
      __extends(StartEventable, _super);

      function StartEventable() {
        this.stopEvent = __bind(this.stopEvent, this);
        this.startEvent = __bind(this.startEvent, this);
        return StartEventable.__super__.constructor.apply(this, arguments);
      }

      StartEventable.prototype.bind = function(ev, callback) {
        StartEventable.__super__.bind.apply(this, arguments);
        if (this.startEventTest()) {
          return this.startEvent();
        }
      };

      StartEventable.prototype.unbind = function(ev, callback) {
        StartEventable.__super__.unbind.apply(this, arguments);
        if (!this.startEventTest()) {
          return this.stopEvent();
        }
      };

      StartEventable.prototype.startEvent = function(event) {
        if (this.eventStarted) {
          return;
        }
        return this.eventStarted = true;
      };

      StartEventable.prototype.stopEvent = function(event) {
        if (!this.eventStarted) {
          return;
        }
        return this.eventStarted = false;
      };

      return StartEventable;

    })(Eventable);

    /**
     * @class dr.idle
     * @extends Eventable
     * Sends onidle events when the application is active and idle.
     *
     *     @example
     *     <handler event="onidle" reference="dr.idle" args="idleStatus">
     *       milis.setAttribute('text', idleStatus);
     *     </handler>
     *
     *     <simplelayout axis="x"></simplelayout>
     *     <text text="Miliseconds since app started: "></text>
     *     <text id="milis"></text>
     */
    Idle = (function(_super) {
      __extends(Idle, _super);

      function Idle() {
        this.sender = __bind(this.sender, this);
        this.startEvent = __bind(this.startEvent, this);
        return Idle.__super__.constructor.apply(this, arguments);
      }

      Idle.prototype.startEventTest = function() {
        var start, _ref;
        start = (_ref = this.events['idle']) != null ? _ref.length : void 0;
        if (start) {
          return start;
        }
      };

      Idle.prototype.startEvent = function(event) {
        Idle.__super__.startEvent.apply(this, arguments);
        return idle(1, this.sender);
      };

      Idle.prototype.sender = function(time) {

        /**
         * @event onidle 
         * Fired when the application is active and idle.
         * @param {Number} time The number of milliseconds since the application started
         */
        this.sendEvent('idle', time);
        return setTimeout((function(_this) {
          return function() {
            return idle(1, _this.sender);
          };
        })(this), 0);
      };

      return Idle;

    })(StartEventable);
    mouseEvents = ['click', 'mouseover', 'mouseout', 'mousedown', 'mouseup'];

    /**
     * @class dr.mouse
     * @extends Eventable
     * Sends mouse events. Often used to listen to onmouseover/x/y events to follow the mouse position.
     *
     * Here we attach events handlers to the onx and ony events of dr.mouse, and set the x,y coordinates of a square view so it follows the mouse.
     *
     *     @example
     *     <view id="mousetracker" width="20" height="20" bgcolor="MediumTurquoise"></view>
     *
     *     <handler event="onx" args="x" reference="dr.mouse">
     *       mousetracker.setAttribute('x', x);
     *     </handler>
     *
     *     <handler event="ony" args="y" reference="dr.mouse">
     *       mousetracker.setAttribute('y', y);
     *     </handler>
     *
     *
     */
    Mouse = (function(_super) {
      __extends(Mouse, _super);


      /**
       * @event onclick 
       * Fired when the mouse is clicked
       * @param {dr.view} view The dr.view that fired the event
       */


      /**
       * @event onmouseover 
       * Fired when the mouse moves over a view
       * @param {dr.view} view The dr.view that fired the event
       */


      /**
       * @event onmouseout 
       * Fired when the mouse moves off a view
       * @param {dr.view} view The dr.view that fired the event
       */


      /**
       * @event onmousedown 
       * Fired when the mouse goes down on a view
       * @param {dr.view} view The dr.view that fired the event
       */


      /**
       * @event onmouseup 
       * Fired when the mouse goes up on a view
       * @param {dr.view} view The dr.view that fired the event
       */

      function Mouse() {
        this.sender = __bind(this.sender, this);
        this.handle = __bind(this.handle, this);
        this.x = 0;
        this.y = 0;
        this.docSelector = $(document);
        this.docSelector.on(mouseEvents.join(' '), this.handle);
        this.docSelector.on("mousemove", this.handle).one("mouseout", this.stopEvent);
      }

      Mouse.prototype.startEventTest = function() {
        var _ref, _ref1, _ref2;
        return ((_ref = this.events['mousemove']) != null ? _ref.length : void 0) || ((_ref1 = this.events['x']) != null ? _ref1.length : void 0) || ((_ref2 = this.events['y']) != null ? _ref2.length : void 0);
      };

      Mouse.prototype.handle = function(event) {
        var type, view;
        view = event.target.$view;
        type = event.type;
        if (view) {
          if (type === 'mousedown') {
            this._lastMouseDown = view;
          }
        }
        if (type === 'mouseup' && this._lastMouseDown && this._lastMouseDown !== view) {
          this.sendEvent('mouseup', this._lastMouseDown);
          this._lastMouseDown.sendEvent('mouseup', this._lastMouseDown);
          this.sendEvent('mouseupoutside', this._lastMouseDown);
          this._lastMouseDown.sendEvent('mouseupoutside', this._lastMouseDown);
          this._lastMouseDown = null;
          return;
        } else if (view) {
          view.sendEvent(type, view);
        }

        /**
         * @property {Number} x
         * @readonly
         * The x coordinate of the mouse
         */
        this.x = event.pageX;

        /**
         * @property {Number} y
         * @readonly
         * The y coordinate of the mouse
         */
        this.y = event.pageY;
        if (this.eventStarted && type === 'mousemove') {
          return idle(0, this.sender);
        } else {
          return this.sendEvent(type, view);
        }
      };

      Mouse.prototype.sender = function() {

        /**
         * @event onmousemove 
         * Fired when the mouse moves
         * @param {Object} coordinates The x and y coordinates of the mouse
         */
        this.sendEvent("mousemove", {
          x: this.x,
          y: this.y
        });

        /**
         * @event onx 
         * Fired when the mouse moves in the x axis
         * @param {Number} x The x coordinate of the mouse
         */
        this.sendEvent('x', this.x);

        /**
         * @event ony 
         * Fired when the mouse moves in the y axis
         * @param {Number} y The y coordinate of the mouse
         */
        return this.sendEvent('y', this.y);
      };

      Mouse.prototype.handleDocEvent = function(event) {
        if (event && event.target !== document) {
          return;
        }
        if (this.eventStarted) {
          return this.docSelector.on("mousemove", this.handle).one("mouseout", this.stopEvent);
        } else {
          return this.docSelector.on("mousemove", this.handle).one("mouseout", this.startEvent);
        }
      };

      return Mouse;

    })(StartEventable);

    /**
     * @class dr.window
     * @extends Eventable
     * Sends window resize events. Often used to dynamically reposition views as the window size changes.
     *
     *     @example
     *     <handler event="onwidth" reference="dr.window" args="newWidth">
     *       //adjust views
     *     </handler>
     *
     *     <handler event="onheight" reference="dr.window" args="newHeight">
     *       //adjust views
     *     </handler>
     *
     *
     */
    Window = (function(_super) {
      __extends(Window, _super);

      function Window() {
        this.handle = __bind(this.handle, this);
        var handleVisibilityChange, hidden, visibilityChange;
        window.addEventListener('resize', this.handle, false);
        this.visible = true;
        if (document.hidden != null) {
          hidden = "hidden";
          visibilityChange = "visibilitychange";
        } else if (document.mozHidden != null) {
          hidden = "mozHidden";
          visibilityChange = "mozvisibilitychange";
        } else if (document.msHidden != null) {
          hidden = "msHidden";
          visibilityChange = "msvisibilitychange";
        } else if (document.webkitHidden != null) {
          hidden = "webkitHidden";
          visibilityChange = "webkitvisibilitychange";
        }
        handleVisibilityChange = (function(_this) {
          return function() {
            _this.visible = document[hidden];

            /**
             * @event onvisible 
             * Fired when the window visibility changes
             * @param {Boolean} visible True if the window is currently visible
             */
            return _this.sendEvent('visible', _this.visible);
          };
        })(this);
        document.addEventListener(visibilityChange, handleVisibilityChange, false);
        this.handle();
      }

      Window.prototype.startEventTest = function() {
        var _ref, _ref1;
        return ((_ref = this.events['width']) != null ? _ref.length : void 0) || ((_ref1 = this.events['height']) != null ? _ref1.length : void 0);
      };

      Window.prototype.handle = function(event) {
        this.width = window.innerWidth;

        /**
         * @event onwidth 
         * Fired when the window resizes
         * @param {Number} width The width of the window
         */
        this.sendEvent('width', this.width);
        this.height = window.innerHeight;

        /**
         * @event onheight 
         * Fired when the window resizes
         * @param {Number} height The height of the window
         */
        return this.sendEvent('height', this.height);
      };

      return Window;

    })(StartEventable);

    /**
     * @class dr.keyboard
     * @extends Eventable
     * Sends keyboard events.
     *
     * You might want to track specific keyboard events when text is being entered into an input box. In this example we listen for the enter key and display the value.
     *
     *     @example
     *     <simplelayout axis="y" spacing="25"></simplelayout>
     *     <inputtext id="nameinput" bgcolor="lightgrey"></inputtext>
     *     <text id="keycode" text="Key Code:"></text>
     *     <text id="entered"></text>
     *
     *     <handler event="onkeyup" args="keys" reference="dr.keyboard">
     *       keycode.setAttribute('text', 'Key Code: ' + keys.keyCode);
     *       if (keys.keyCode == 13) {
     *         entered.setAttribute('text', 'You entered: ' + nameinput.text);
     *         nameinput.setAttribute('text', '');
     *       }
     *     </handler>
     */
    Keyboard = (function(_super) {
      var keyboardEvents, keys;

      __extends(Keyboard, _super);

      keyboardEvents = ['select', 'keyup', 'keydown', 'change'];

      keys = {
        shiftKey: false,
        altKey: false,
        ctrlKey: false,
        metaKey: false,
        keyCode: 0
      };

      function Keyboard() {
        this.handle = __bind(this.handle, this);
        $(document).on(keyboardEvents.join(' '), this.handle);
      }

      Keyboard.prototype.handle = function(event) {
        var key, out, target, type, value;
        target = event.target.$view;
        type = event.type;
        if (type !== 'select') {
          for (key in keys) {
            value = keys[key];
            keys[key] = event[key];
          }
        }
        keys.type = type;
        if (target) {
          target.sendEvent(type, keys);
          if (type === 'keydown' || type === 'keyup' || type === 'blur' || type === 'change') {
            value = event.target.value;
            if (target.text !== value) {
              target.text = value;
              target.sendEvent('text', value);
            }
          }
        }
        out = type === 'select' ? target : keys;

        /**
         * @event onselect 
         * Fired when text is selected
         * @param {dr.view} view The view that fired the event
         */

        /**
         * @event onchange 
         * Fired when an inputtext has changed
         * @param {dr.view} view The view that fired the event
         */

        /**
         * @event onkeydown 
         * Fired when a key goes down
         * @param {Object} keys An object representing the keyboard state, including shiftKey, allocation, ctrlKey, metaKey, keyCode and type
         */

        /**
         * @event onkeyup 
         * Fired when a key goes up
         * @param {Object} keys An object representing the keyboard state, including shiftKey, allocation, ctrlKey, metaKey, keyCode and type
         */
        this.sendEvent(type, out);

        /**
         * @event onkeys 
         * Fired when a key is pressed on the keyboard
         * @param {Object} keys An object representing the keyboard state, including shiftKey, allocation, ctrlKey, metaKey, keyCode and type
         */
        if (type !== 'select') {
          return this.sendEvent('keys', out);
        }
      };

      return Keyboard;

    })(Eventable);

    /**
     * @class dr
     * Holds builtin and user-created classes and public APIs.
     * 
     * All classes listed here can be invoked with the declarative syntax, e.g. &lt;node>&lt;/node> or &lt;view>&lt;/view>
     */
    return exports = {
      view: View,
      text: Text,
      inputtext: InputText,
      "class": Class,
      node: Node,
      mouse: new Mouse(),
      keyboard: new Keyboard(),
      window: new Window(),
      layout: Layout,
      idle: new Idle(),
      state: State,

      /**
       * @method initElements
       * Initializes all top-level views found in the document. Called automatically when the page loads, but can be called manually as needed.
       */
      initElements: dom.initAllElements,

      /**
       * @method writeCSS
       * Writes generic dreem-specific CSS to the document. Should only be called once.
       */
      writeCSS: dom.writeCSS
    };

    /**
     * @class dr.method
     * Declares a member function in a node, view, class or other class instance. Methods can only be created with the &lt;method>&lt;/method> tag syntax.
     * 
     * If a method overrides an existing method, any existing (super) method(s) will be called first automatically.
     *
     * Let's define a method called changeColor in a view that sets the background color to pink.
     *
     *     @example
     *
     *     <view id="square" width="100" height="100">
     *       <method name="changeColor">
     *         this.setAttribute('bgcolor', 'pink');
     *       </method>
     *     </view>
     *
     *     <handler event="oninit">
     *       square.changeColor();
     *     </handler>
     *
     * Here we define the changeColor method in a class called square. We create an instance of the class and call the method on the intance.
     *
     *     @example
     *     <class name="square" width="100" height="100">
     *       <method name="changeColor">
     *         this.setAttribute('bgcolor', 'pink');
     *       </method>
     *     </class>
     *
     *     <square id="square1"></square>
     *
     *     <handler event="oninit">
     *       square1.changeColor();
     *     </handler>
     *
     * Now we'll subclass the square class with a bluesquare class, and override the changeColor method to color the square blue. We also add an inner square who's color is set in the changeColor method of the square superclass. Notice that the color of this square is set when the method is called on the subclass.
     *
     *     @example
     *     <class name="square" width="100" height="100">
     *       <view name="inner" width="25" height="25"></view>
     *       <method name="changeColor">
     *         this.inner.setAttribute('bgcolor', 'green');
     *         this.setAttribute('bgcolor', 'pink');
     *       </method>
     *     </class>
     *
     *     <class name="bluesquare" extends="square">
     *       <method name="changeColor">
     *         this.setAttribute('bgcolor', 'blue');
     *       </method>
     *     </class>
     *
     *     <simplelayout axis="x"></simplelayout>
     *
     *     <square id="square1"></square>
     *     <bluesquare id="square2"></bluesquare>
     *
     *     <handler event="oninit">
     *       square1.changeColor();
     *       square2.changeColor();
     *     </handler>
     *
     */

    /**
     * @cfg {String} name (required)
     * The name of the method.
     */

    /**
     * @cfg {String[]} args
     * A comma separated list of method arguments.
     */

    /**
     * @cfg {"js"/"coffee"} type 
     * The compiler to use for this method. Inherits from the immediate class if unspecified.
     */

    /**
     * @class dr.setter
     * Declares a setter in a node, view, class or other class instance. Setters can only be created with the &lt;setter>&lt;/setter> tag syntax.
     *
     * Setters allow the default behavior of attribute changes to be changed.
     * 
     * Like dr.method, if a setter overrides an existing setter any existing (super) setter(s) will be called first automatically.
     * @ignore
     */

    /**
     * @cfg {String} name (required)
     * The name of the method.
     */

    /**
     * @cfg {String[]} args
     * A comma separated list of method arguments.
     */

    /**
     * @cfg {"js"/"coffee"} type 
     * The compiler to use for this method. Inherits from the immediate class if unspecified.
     */

    /**
     * @class dr.handler
     * Declares a handler in a node, view, class or other class instance. Handlers can only be created with the &lt;handler>&lt;/handler> tag syntax.
     *
     * Handlers are called when an event fires with new value, if available.
     *
     * Here is a simple handler that listens for an onx event in the local scope. The handler runs when x changes:
     *
     *     @example
     *     <handler event="onx">
     *       // do something now that x has changed
     *     </handler>
     *
     * When a handler uses the args attribute, it can recieve the value that changed:
     *
     *     @example
     *     <handler event="onx" args="x">
     *       console.log('received x', x);
     *     </handler>
     *
     * It's also possible to listen for events on another scope. This handler listens for onidle events on dr.idle instead of the local scope:
     *
     *     @example
     *     <handler event="onidle" args="time" reference="dr.idle">
     *       console.log('received time from dr.idle.onidle', time);
     *     </handler>
     *
     * Sometimes it's nice to use a single method to respond to multiple events:
     *
     *     @example
     *     <handler event="onx" method="handlePosition"></handler>
     *     <handler event="ony" method="handlePosition"></handler>
     *     <method name="handlePosition">
     *       // do something now that x or y have changed
     *     </method>
     */

    /**
     * @cfg {String} event (required)
     * The name of the event to listen for, e.g. 'onwidth'.
     */

    /**
     * @cfg {String} reference
     * If set, the handler will listen for an event in another scope.
     */

    /**
     * @cfg {String} method
     * If set, the handler call a local method. Useful when multiple handlers need to do the same thing.
     */

    /**
     * @cfg {String[]} args
     * A comma separated list of method arguments.
     */

    /**
     * @cfg {"js"/"coffee"} type 
     * The compiler to use for this method. Inherits from the immediate class if unspecified.
     */

    /**
     * @class dr.attribute
     * Adds a variable to a node, view, class or other class instance. Attributes can only be created with the &lt;attribute>&lt;/attribute> tag syntax.
     * 
     * Attributes allow classes to declare new variables with a specific type and default value. 
     *
     * Attributes automatically send events when their value changes.
     *
     * Here we create a new class with a custom attribute representing a person's mood, along with two instances. One instance has the default mood of 'happy', the other sets the mood attribute to 'sad'. Note there's nothing visible in this example yet:
     *
     *     @example
     *     <class name="person">
     *       <attribute name="mood" type="string" value="happy"></attribute>
     *     </class>
     *
     *     <person></person>
     *     <person mood="sad"></person>
     *
     * Let's had a handler to make our color change with the mood. Whenever the mood attribute changes, the color changes with it:
     *
     *     @example
     *     <class name="person" width="100" height="100">
     *       <attribute name="mood" type="string" value="happy"></attribute>
     *       <handler event="onmood" args="mood">
     *         var color = 'orange';
     *         if (mood !== 'happy') {
     *           color = 'blue'
     *         }
     *         this.setAttribute('bgcolor', color);
     *       </handler>
     *     </class>
     * 
     *     <simplelayout></simplelayout>
     *     <person></person>
     *     <person mood="sad"></person>
     *
     * You can add as many attributes as you like to a class. Here, we add a numeric attribute for size, which changes the height and width attributes via a constraint:
     *
     *     @example
     *     <class name="person" width="${this.size}" height="${this.size}">
     *       <attribute name="mood" type="string" value="happy"></attribute>
     *       <handler event="onmood" args="mood">
     *         var color = 'orange';
     *         if (mood !== 'happy') {
     *           color = 'blue'
     *         }
     *         this.setAttribute('bgcolor', color);
     *       </handler>
     *       <attribute name="size" type="number" value="20"></attribute>
     *     </class>
     * 
     *     <simplelayout></simplelayout>
     *     <person></person>
     *     <person mood="sad" size="50"></person>
     */

    /**
     * @cfg {String} name (required)
     * The name of the attribute
     */

    /**
     * @cfg {"string"/"number"/"boolean"/"json"} [type=string] (required)
     * The type of the attribute. Used to convert from a string to an appropriate representation of the type.
     */

    /**
     * @cfg {String} value (required)
     * The initial value for the attribute
     */
  })();

  dr.writeCSS();

  $(window).on('load', function() {
    dr.initElements();
    return hackstyle(true);
  });

}).call(this);

//# sourceMappingURL=layout.js.map

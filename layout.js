// Generated by CoffeeScript 1.8.0

/*
 * The MIT License (MIT)
 * 
 * Copyright ( c ) 2014 Teem2 LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

(function() {
  var hackstyle, stylemap,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  stylemap = {
    x: 'marginLeft',
    y: 'marginTop',
    bgcolor: 'backgroundColor',
    visible: 'display',
    border: 'borderWidth',
    borderstyle: 'borderStyle',
    bordercolor: 'borderColor'
  };

  hackstyle = (function() {
    var monitoredJQueryStyleProps, origstyle, prop, styletap, value;
    monitoredJQueryStyleProps = {};
    for (prop in stylemap) {
      value = stylemap[prop];
      monitoredJQueryStyleProps[value] = prop;
    }
    origstyle = $.style;
    styletap = function(elem, name, value) {
      var attrName, view;
      attrName = monitoredJQueryStyleProps[name];
      if (attrName == null) {
        attrName = monitoredJQueryStyleProps[name.replace(/-([a-z])/i, function(m) {
          return m[1].toUpperCase();
        })];
        monitoredJQueryStyleProps[name] = attrName ? attrName : name;
      }
      view = elem.$view;
      if (view[attrName] !== value) {
        view.setAttribute(attrName, value, true);
      }
      return origstyle.apply(this, arguments);
    };
    return function(active) {
      if (active) {
        return $.style = styletap;
      } else {
        return $.style = origstyle;
      }
    };
  })();

  window.dr = (function() {
    var Class, Eventable, Events, Idle, InputText, Keyboard, Layout, Module, Mouse, Node, Sprite, StartEventable, State, Text, View, Window, capabilities, compiler, constraintScopes, debug, dom, exports, fcamelCase, hiddenAttributes, idle, ignoredAttributes, mixOf, moduleKeywords, mouseEvents, otherstyles, querystring, rdashAlpha, showWarnings, ss, ss2, test, triggerlock, warnings, _initConstraints;
    mixOf = function() {
      var Mixed, base, i, method, mixin, mixins, name, _i, _ref;
      base = arguments[0], mixins = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      Mixed = (function(_super) {
        __extends(Mixed, _super);

        function Mixed() {
          return Mixed.__super__.constructor.apply(this, arguments);
        }

        return Mixed;

      })(base);
      for (i = _i = mixins.length - 1; _i >= 0; i = _i += -1) {
        mixin = mixins[i];
        _ref = mixin.prototype;
        for (name in _ref) {
          method = _ref[name];
          Mixed.prototype[name] = method;
        }
      }
      return Mixed;
    };

    /**
     * @class Events
     * @private
     * A lightweight event system, used internally.
     */
    triggerlock = null;
    Events = {

      /**
       * Binds an event to the current scope
       * @param {String} ev the name of the event
       * @param {Function} callback called when the event is fired
       */
      bind: function(ev, callback) {
        var evs, name, _base, _i, _len;
        evs = ev.split(' ');
        if (!(this.hasOwnProperty('events') && this.events)) {
          this.events = {};
        }
        for (_i = 0, _len = evs.length; _i < _len; _i++) {
          name = evs[_i];
          (_base = this.events)[name] || (_base[name] = []);
          this.events[name].push(callback);
        }
        return this;
      },

      /**
       * Binds an event to the current scope, automatically unbinds when the event fires
       * @param {String} ev the name of the event
       * @param {Function} callback called when the event is fired
       */
      one: function(ev, callback) {
        this.bind(ev, function() {
          this.unbind(ev, arguments.callee);
          return callback.apply(this, arguments);
        });
        return this;
      },

      /**
       * Fires an event
       * @param {String} ev the name of the event to fire
       */
      trigger: function() {
        var args, callback, ev, list, _i, _len, _ref;
        ev = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        list = this.hasOwnProperty('events') && ((_ref = this.events) != null ? _ref[ev] : void 0);
        if (!list) {
          return;
        }
        if (triggerlock && triggerlock.scope === this && triggerlock.ev === ev) {
          return this;
        }
        if (!triggerlock) {
          triggerlock = {
            ev: ev,
            scope: this
          };
        }
        for (_i = 0, _len = list.length; _i < _len; _i++) {
          callback = list[_i];
          if (callback.apply(this, args) === false) {
            break;
          }
        }
        triggerlock = null;
        return this;
      },

      /**
       * Listens for an event on a specific scope
       * @param {Object} obj scope to listen for events on
       * @param {String} ev the name of the event
       * @param {Function} callback called when the event is fired
       */
      listenTo: function(obj, ev, callback) {
        obj.bind(ev, callback);
        this.listeningTo || (this.listeningTo = []);
        this.listeningTo.push({
          obj: obj,
          ev: ev,
          callback: callback
        });
        return this;
      },

      /**
       * Only listens for an event one time
       * @param {Object} obj scope to listen for events on
       * @param {String} ev the name of the event
       * @param {Function} callback called when the event is fired
       */
      listenToOnce: function(obj, ev, callback) {
        var listeningToOnce;
        listeningToOnce = this.listeningToOnce || (this.listeningToOnce = []);
        listeningToOnce.push(obj);
        obj.one(ev, function() {
          var idx;
          idx = listeningToOnce.indexOf(obj);
          if (idx !== -1) {
            listeningToOnce.splice(idx, 1);
          }
          return callback.apply(this, arguments);
        });
        return this;
      },

      /**
       * Stops listening for an event on a given scope
       * @param {Object} obj scope to listen for events on
       * @param {String} ev the name of the event
       * @param {Function} callback called when the event would have been fired
       */
      stopListening: function(obj, ev, callback) {
        var idx, index, listeningTo, val, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
        if (obj) {
          obj.unbind(ev, callback);
          _ref = [this.listeningTo, this.listeningToOnce];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            listeningTo = _ref[_i];
            if (!listeningTo) {
              continue;
            }
            idx = listeningTo.indexOf(obj);
            if (idx > -1) {
              listeningTo.splice(idx, 1);
            } else {
              for (index = _j = 0, _len1 = listeningTo.length; _j < _len1; index = ++_j) {
                val = listeningTo[index];
                if (obj === val.obj && ev === val.ev && callback === val.callback) {
                  listeningTo.splice(index, 1);
                  break;
                }
              }
            }
          }
        } else {
          _ref1 = this.listeningTo;
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            _ref2 = _ref1[_k], obj = _ref2.obj, ev = _ref2.ev, callback = _ref2.callback;
            obj.unbind(ev, callback);
          }
          this.listeningTo = void 0;
        }
        return this;
      },

      /**
       * Stops listening for an event on the current scope
       * @param {String} ev the name of the event
       * @param {Function} callback called when the event would have been fired
       */
      unbind: function(ev, callback) {
        var cb, evs, i, list, name, _i, _j, _len, _len1, _ref;
        if (!ev) {
          this.events = {};
          return this;
        }
        evs = ev.split(' ');
        for (_i = 0, _len = evs.length; _i < _len; _i++) {
          name = evs[_i];
          list = (_ref = this.events) != null ? _ref[name] : void 0;
          if (!list) {
            continue;
          }
          if (!callback) {
            delete this.events[name];
            continue;
          }
          for (i = _j = 0, _len1 = list.length; _j < _len1; i = ++_j) {
            cb = list[i];
            if (!(cb === callback)) {
              continue;
            }
            list = list.slice();
            list.splice(i, 1);
            this.events[name] = list;
            break;
          }
        }
        return this;
      }
    };

    /**
     * @class Module
     * @private
     * Adds basic mixin support.
     */
    moduleKeywords = ['included', 'extended'];
    Module = (function() {
      function Module() {}


      /**
       * Includes a mixin in the current scope
       * @param {Object} obj the object to be mixed in
       */

      Module.include = function(obj) {
        var key, value, _ref;
        if (!obj) {
          throw new Error('include(obj) requires obj');
        }
        for (key in obj) {
          value = obj[key];
          if (__indexOf.call(moduleKeywords, key) < 0) {
            this.prototype[key] = value;
          }
        }
        if ((_ref = obj.included) != null) {
          _ref.call(this, obj);
        }
        return this;
      };

      return Module;

    })();

    /**
     * @class Eventable {Core Dreem}
     * @extends Module
     * The baseclass used by everything in dreem. Adds higher level event APIs.
     */
    Eventable = (function(_super) {

      /**
       * @method include
       * @hide
       */
      var eventlock, typemappings;

      __extends(Eventable, _super);

      function Eventable() {
        return Eventable.__super__.constructor.apply(this, arguments);
      }

      Eventable.include(Events);

      typemappings = {
        number: parseFloat,
        boolean: function(val) {
          if (typeof val === 'string') {
            return val === 'true';
          } else {
            return !!val;
          }
        },
        string: function(val) {
          return val + '';
        },
        json: function(val) {
          return JSON.parse(val);
        },
        expression: function(val) {
          if (typeof val !== 'string') {
            return val;
          }
          return eval(val);
        }
      };

      eventlock = {};

      Eventable.prototype._coerceType = function(name, value, type) {
        type || (type = this.types[name]);
        if (type) {
          if (!typemappings[type]) {
            showWarnings(["Invalid type '" + type + "' for attribute '" + name + "', must be one of: " + (Object.keys(typemappings).join(', '))]);
            return;
          }
          value = typemappings[type](value);
        } else if (value == null) {
          value = '';
        }
        return value;
      };

      Eventable.prototype._setDefaults = function(attributes, defaults) {
        var key, value, _results;
        if (defaults == null) {
          defaults = {};
        }
        _results = [];
        for (key in defaults) {
          value = defaults[key];
          if (!(key in attributes)) {
            _results.push(attributes[key] = defaults[key]);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };


      /**
       * Sets an attribute, calls a setter if there is one, then sends an event with the new value
       * @param {String} name the name of the attribute to set
       * @param value the value to set to
       */

      Eventable.prototype.setAttribute = function(name, value, skipcoercion, skipConstraintSetup, skipconstraintunregistration) {
        var _name;
        if (!skipcoercion) {
          value = this._coerceType(name, value);
        }
        if (!skipconstraintunregistration) {
          if ((this.constraints != null) && name in this.constraints) {
            this._unbindConstraint(name);
          }
        }
        if (typeof this[_name = "set_" + name] === "function") {
          this[_name](value);
        }
        this[name] = value;
        this.sendEvent(name, value);
        return this;
      };


      /**
       * Sends an event
       * @param {String} name the name of the event to send
       * @param value the value to send with the event
       */

      Eventable.prototype.sendEvent = function(name, value) {
        var _ref;
        if ((_ref = this.events) != null ? _ref[name] : void 0) {
          this.trigger(name, value, this);
        }
        return this;
      };


      /**
       * Calls setAttribute for each name/value pair in the attributes object
       * @param {Object} attributes An object of name/value pairs to be set
       */

      Eventable.prototype.setAttributes = function(attributes) {
        var name, value;
        for (name in attributes) {
          value = attributes[name];
          this.setAttribute(name, value);
        }
        return this;
      };

      return Eventable;

    })(Module);
    capabilities = {
      localStorage: (function() {
        var e, mod;
        mod = 'dr';
        try {
          localStorage.setItem(mod, mod);
          localStorage.removeItem(mod);
          return true;
        } catch (_error) {
          e = _error;
          return false;
        }
      })(),
      touch: 'ontouchstart' in window || 'onmsgesturechange' in window,
      camelcss: navigator.userAgent.toLowerCase().indexOf('firefox') > -1
    };
    querystring = window.location.search;
    debug = querystring.indexOf('debug') > 0;
    test = querystring.indexOf('test') > 0;
    compiler = (function() {
      var cacheData, cacheKey, compile, compileCache, compiledebug, exports, findBindings, nocache, scriptCache, strict, transform, usecache;
      nocache = querystring.indexOf('nocache') > 0;
      strict = querystring.indexOf('strict') > 0;
      if (!nocache) {
        usecache = capabilities.localStorage;
      }
      cacheKey = "dreemcache";
      cacheData = localStorage.getItem(cacheKey);
      if (usecache && cacheData && cacheData.length < 5000000) {
        compileCache = JSON.parse(cacheData);
      } else {
        localStorage.clear();
        compileCache = {
          bindings: {},
          script: {
            coffee: {}
          }
        };
        if (usecache) {
          localStorage[cacheKey] = JSON.stringify(compileCache);
        }
      }
      window.addEventListener('unload', function() {
        if (usecache) {
          return localStorage[cacheKey] = JSON.stringify(compileCache);
        }
      });
      findBindings = (function() {
        var bindingCache, propertyBindings, scopes;
        bindingCache = compileCache.bindings;
        scopes = null;
        propertyBindings = {
          MemberExpression: function(n) {
            var name;
            name = n.property.name;
            n = n.object;
            scopes.push({
              binding: acorn.stringify(n),
              property: name
            });
            return true;
          }
        };
        return function(expression) {
          var ast;
          if (usecache && expression in bindingCache) {
            return bindingCache[expression];
          }
          ast = acorn.parse(expression);
          scopes = [];
          acorn.walkDown(ast, propertyBindings);
          return bindingCache[expression] = scopes;
        };
      })();
      transform = (function() {
        var coffeeCache, compilers;
        coffeeCache = compileCache.script.coffee;
        compilers = {
          coffee: function(script) {
            var error;
            if (usecache && script in coffeeCache) {
              return coffeeCache[script];
            }
            if (!window.CoffeeScript) {
              console.warn('missing coffee-script.js include');
              return;
            }
            try {
              if (script) {
                return coffeeCache[script] = CoffeeScript.compile(script, {
                  bare: true
                });
              }
            } catch (_error) {
              error = _error;
              return showWarnings(["error " + error + " compiling script\r\n" + script]);
            }
          }
        };
        return function(script, name) {
          if (script == null) {
            script = '';
          }
          if (!(name in compilers)) {
            return script;
          }
          return compilers[name](script);
        };
      })();
      scriptCache = {};
      compiledebug = function(script, args, name) {
        var argstring, e, func, key;
        if (script == null) {
          script = '';
        }
        if (args == null) {
          args = [];
        }
        if (name == null) {
          name = '';
        }
        argstring = args.join();
        key = script + argstring + name;
        if (key in scriptCache) {
          return scriptCache[key];
        }
        try {
          if (strict) {
            script = "\"use strict\"\n" + script;
          }
          if (name) {
            func = new Function("return function " + name + "(" + argstring + "){" + script + "}")();
          } else {
            func = new Function(args, script);
          }
          return scriptCache[key] = func;
        } catch (_error) {
          e = _error;
          return console.error('failed to compile', e.toString(), args, script);
        }
      };
      compile = function(script, args, name) {
        var argstring, key;
        if (script == null) {
          script = '';
        }
        if (args == null) {
          args = [];
        }
        if (name == null) {
          name = '';
        }
        argstring = args.join();
        key = script + argstring + name;
        if (key in scriptCache) {
          return scriptCache[key];
        }
        return scriptCache[key] = new Function(args, script);
      };
      return exports = {
        compile: debug ? compiledebug : compile,
        transform: transform,
        findBindings: findBindings
      };
    })();
    constraintScopes = [];
    _initConstraints = function() {
      var constraint, _i, _len;
      for (_i = 0, _len = constraintScopes.length; _i < _len; _i++) {
        constraint = constraintScopes[_i];
        constraint._bindConstraints();
      }
      return constraintScopes = [];
    };

    /**
     * @class dr.node {Core Dreem}
     * @extends Eventable
     * The nonvisual base class for everything in dreem. Handles parent/child relationships between tags.
     *
     * Nodes can contain methods, handlers, setters, [constraints](#!/guide/constraints), attributes and other node instances.
     *
     * Here we define a data node that contains movie data.
     *
     *     <node id="data">
     *       <node>
     *         <attribute name="title" type="string" value="Bill and Teds Excellent Adventure"></attribute>
     *         <attribute name="type" type="string" value="movie"></attribute>
     *         <attribute name="year" type="string" value="1989"></attribute>
     *         <attribute name="length" type="number" value="89"></attribute>
     *       </node>
     *       <node>
     *         <attribute name="title" type="string" value="Waynes World"></attribute>
     *         <attribute name="type" type="string" value="movie"></attribute>
     *         <attribute name="year" type="string" value="1992"></attribute>
     *         <attribute name="length" type="number" value="94"></attribute>
     *       </node>
     *     </node>
     *
     * This node defines a set of math helper methods. The node provides a tidy container for these related utility functions.
     *
     *     <node id="utils">
     *       <method name="add" args="a,b">
     *         return a+b;
     *       </method>
     *       <method name="subtract" args="a,b">
     *         return a-b;
     *       </method>
     *     </node>
     *
     * You can also create a sub-class of node to contain non visual functionality. Here is an example of an inches to metric conversion class that is instantiated with the inches value and can convert it to either cm or m.
     *
     *     @example
     *
     *     <class name="inchesconverter" extends="node">
     *       <attribute name="inchesval" type="number" value="0"></attribute>
     *
     *       <method name="centimetersval">
     *         return this.inchesval*2.54;
     *       </method>
     *
     *       <method name="metersval">
     *         return (this.inchesval*2.54)/100;
     *       </method>
     *     </class>
     *
     *     <inchesconverter id="conv" inchesval="2"></inchesconverter>
     *
     *     <spacedlayout axis="y"></spacedlayout>
     *     <text text="${conv.inchesval + ' inches'}"></text>
     *     <text text="${conv.centimetersval() + ' cm'}"></text>
     *     <text text="${conv.metersval() + ' m'}"></text>
     *
     *
     */
    Node = (function(_super) {

      /**
       * @attribute {String} name
       * Names this node in its parent scope so it can be referred to later.
       */

      /**
       * @attribute {String} id
       * Gives this node a global ID, which can be looked up in the global window object.
       * Take care to not override builtin globals, or override your own instances!
       */

      /**
       * @attribute {String} scriptincludes
       * A comma separated list of URLs to javascript includes required as dependencies. Useful if you need to ensure a third party library is available.
       */

      /**
       * @attribute {String} scriptincludeserror
       * An error to show if scriptincludes fail to load
       */
      var earlyattributes, lateattributes, matchConstraint, _eventCallback, _installMethod;

      __extends(Node, _super);

      matchConstraint = /\${(.+)}/;

      earlyattributes = ['name', 'parent'];

      lateattributes = ['data'];

      function Node(el, attributes) {
        var args, deferbindings, ev, method, name, parent, reference, script, skiponinit, value, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
        if (attributes == null) {
          attributes = {};
        }

        /**
         * @property {dr.node[]} subnodes
         * @readonly
         * An array of this node's child nodes
         */
        this.subnodes = [];
        this.types = (_ref = attributes.$types) != null ? _ref : {};
        delete attributes.$types;
        skiponinit = attributes.$skiponinit;
        delete attributes.$skiponinit;
        deferbindings = attributes.$deferbindings;
        delete attributes.$deferbindings;

        /*
         * @property {String} $textcontent
         * @readonly
         * Contains the textual contents of this node, if any
         */
        if (el != null ? el.textContent : void 0) {
          attributes.$textcontent = el.textContent;
        }
        if (attributes.$methods) {
          this.installMethods(attributes.$methods, attributes.$tagname);
          delete attributes.$methods;
        }
        if (attributes.$handlers) {
          this.installHandlers(attributes.$handlers, attributes.$tagname);
          _ref1 = attributes.$handlers;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            _ref2 = _ref1[_i], ev = _ref2.ev, name = _ref2.name, script = _ref2.script, args = _ref2.args, reference = _ref2.reference, method = _ref2.method;
            ev = ev.substr(2);
            if (__indexOf.call(mouseEvents, ev) >= 0) {
              if (attributes.clickable !== "false") {
                attributes.clickable = true;
              }
            }
          }
          delete attributes.$handlers;
        }
        if (!deferbindings) {
          this._bindHandlers();
        }
        for (_j = 0, _len1 = earlyattributes.length; _j < _len1; _j++) {
          name = earlyattributes[_j];
          if (name in attributes) {
            this.setAttribute(name, attributes[name]);
          }
        }
        for (name in attributes) {
          value = attributes[name];
          if (__indexOf.call(lateattributes, name) >= 0 || __indexOf.call(earlyattributes, name) >= 0) {
            continue;
          }
          this.bindAttribute(name, value, attributes.$tagname);
        }
        parent = this.parent;
        if (parent && parent instanceof Node) {

          /**
           * @event onsubnodes
           * Fired when this node's subnodes array has changed
           * @param {dr.node} node The dr.node that fired the event
           */

          /**
           * @event subnodeAdded
           * Fired when a subnode is added to this node.
           * @param {dr.node} node The dr.node that was added
           */
          parent.sendEvent('subnodes', this);
          parent.sendEvent('subnodeAdded', this);
          parent.doSubnodeAdded(this);
        }
        for (_k = 0, _len2 = lateattributes.length; _k < _len2; _k++) {
          name = lateattributes[_k];
          if (name in attributes) {
            this.bindAttribute(name, attributes[name], attributes.$tagname);
          }
        }
        if (this.constraints) {
          constraintScopes.push(this);
        }
        if (!deferbindings) {
          this._bindHandlers(true);
        }

        /**
         * @event oninit
         * Fired when this node and all its children are completely initialized
         * @param {dr.node} node The dr.node that fired the event
         */

        /**
         * @property {Boolean} inited
         * @readonly
         * True when this node and all its children are completely initialized
         */
        if (!skiponinit) {
          if (!this.inited) {
            this.inited = true;
            this.sendEvent('init', this);
          }
        }
      }

      Node.prototype.installMethods = function(methods, tagname, scope, callbackscope) {
        var allocation, args, invokeSuper, method, methodlist, name, _i, _len, _ref;
        if (scope == null) {
          scope = this;
        }
        if (callbackscope == null) {
          callbackscope = this;
        }
        for (name in methods) {
          methodlist = methods[name];
          for (_i = 0, _len = methodlist.length; _i < _len; _i++) {
            _ref = methodlist[_i], method = _ref.method, args = _ref.args, allocation = _ref.allocation, invokeSuper = _ref.invokeSuper;
            _installMethod(scope, name, compiler.compile(method, args, "" + tagname + "$" + name).bind(callbackscope), allocation, invokeSuper);
          }
        }
      };

      Node.prototype.installHandlers = function(handlers, tagname, scope) {
        var args, ev, handler, handlerobj, method, name, reference, script, _i, _len;
        if (scope == null) {
          scope = this;
        }
        if (this.handlers == null) {
          this.handlers = [];
        }
        if (this.latehandlers == null) {
          this.latehandlers = [];
        }
        for (_i = 0, _len = handlers.length; _i < _len; _i++) {
          handler = handlers[_i];
          ev = handler.ev, name = handler.name, script = handler.script, args = handler.args, reference = handler.reference, method = handler.method;
          ev = ev.substr(2);
          if (method) {
            handler.callback = scope[method];
          } else {
            handler.callback = _eventCallback(ev, script, scope, tagname, args);
          }
          handlerobj = {
            scope: this,
            ev: ev,
            name: name,
            callback: handler.callback,
            reference: reference
          };
          if (reference) {
            this.latehandlers.push(handlerobj);
          } else {
            this.handlers.push(handlerobj);
          }
        }
      };

      Node.prototype.removeHandlers = function(handlers, tagname, scope) {
        var args, ev, handler, method, name, reference, refeval, script, _i, _len;
        if (scope == null) {
          scope = this;
        }
        for (_i = 0, _len = handlers.length; _i < _len; _i++) {
          handler = handlers[_i];
          ev = handler.ev, name = handler.name, script = handler.script, args = handler.args, reference = handler.reference, method = handler.method;
          ev = ev.substr(2);
          if (reference != null) {
            refeval = this._valueLookup(reference)();
            scope.stopListening(refeval, ev, handler.callback);
          } else {
            scope.unbind(ev, handler.callback);
          }
        }
      };

      Node.prototype.bindAttribute = function(name, value, tagname) {
        var constraint;
        if (value) {
          constraint = typeof value.match === "function" ? value.match(matchConstraint) : void 0;
        }
        if (constraint) {
          return this.setConstraint(name, constraint[1], true);
        } else if (name.indexOf('on') === 0) {
          name = name.substr(2);
          return this.bind(name, _eventCallback(name, value, this, tagname));
        } else {
          return this.setAttribute(name, value);
        }
      };

      Node.prototype.initConstraints = function() {
        _initConstraints();
        return this;
      };

      _eventCallback = function(name, script, scope, tagname, fnargs) {
        var js;
        if (tagname == null) {
          tagname = '';
        }
        if (fnargs == null) {
          fnargs = ['value'];
        }
        js = compiler.compile(script, fnargs, "" + tagname + "$on" + name);
        return function() {
          var args;
          if (arguments.length) {
            args = arguments;
          } else if (name in scope) {
            args = [scope[name]];
          } else {
            args = [];
          }
          return js.apply(scope, args);
        };
      };

      _installMethod = function(scope, methodname, method, allocation, invokeSuper) {
        var meth, supr;
        if (methodname in scope) {
          supr = scope[methodname];
          meth = method;
          return scope[methodname] = function() {
            var prevOwn, prevValue, retval;
            if (invokeSuper === 'after') {
              retval = meth.apply(scope, arguments);
              supr.apply(scope, arguments);
            } else if (invokeSuper === 'inside') {
              prevValue = scope['super'];
              prevOwn = scope.hasOwnProperty('super');
              scope['super'] = function(args) {
                return supr.apply(scope, args);
              };
              retval = meth.apply(scope, arguments);
              if (prevOwn) {
                scope['super'] = prevValue;
              } else {
                delete scope.callSuper;
              }
            } else {
              supr.apply(scope, arguments);
              retval = meth.apply(scope, arguments);
            }
            return retval;
          };
        } else {
          return scope[methodname] = method;
        }
      };

      Node.prototype.setConstraint = function(property, expression, skipbinding) {
        var bindexpression, bindings, scope, scopes, _i, _len;
        if (this.constraints != null) {
          if (property in this.constraints) {
            this._unbindConstraint(property);
          }
        } else {
          this.constraints = {};
        }
        this.constraints[property] = {
          expression: expression,
          bindings: {}
        };
        bindings = this.constraints[property].bindings;
        scopes = compiler.findBindings(expression);
        for (_i = 0, _len = scopes.length; _i < _len; _i++) {
          scope = scopes[_i];
          bindexpression = scope.binding;
          if (bindings[bindexpression] == null) {
            bindings[bindexpression] = [];
          }
          bindings[bindexpression].push(scope);
        }
        if (!skipbinding) {
          this._bindConstraints();
        }
      };

      Node.prototype._valueLookup = function(bindexpression) {
        return compiler.compile('return ' + bindexpression).bind(this);
      };

      Node.prototype._unbindConstraint = function(property) {
        var callback, callbackbindings, constraint, i, prop, scope, _i, _len;
        if (!(property in this.constraints)) {
          return;
        }
        constraint = this.constraints[property];
        callback = constraint.callback, callbackbindings = constraint.callbackbindings;
        for (i = _i = 0, _len = callbackbindings.length; _i < _len; i = _i += 2) {
          prop = callbackbindings[i];
          scope = callbackbindings[i + 1];
          if (typeof scope.unbind === "function") {
            scope.unbind(prop, callback);
          }
        }
        this.constraints[property] = null;
      };

      Node.prototype._bindConstraints = function() {
        var bindexpression, binding, bindinglist, bindings, boundref, constraint, expression, fn, name, property, _i, _len, _ref;
        _ref = this.constraints;
        for (name in _ref) {
          constraint = _ref[name];
          bindings = constraint.bindings, expression = constraint.expression;
          if (constraint.callbackbindings == null) {
            constraint.callbackbindings = [];
          }
          fn = this._valueLookup(expression);
          constraint.callback = this._constraintCallback(name, fn);
          for (bindexpression in bindings) {
            bindinglist = bindings[bindexpression];
            boundref = this._valueLookup(bindexpression)();
            if (!boundref || (boundref.bind == null)) {
              showWarnings(["Could not bind to " + bindexpression + " of constraint " + expression + " for " + this.$tagname + (this.id ? '#' + this.id : this.name ? '.' + name : '')]);
              continue;
            }
            for (_i = 0, _len = bindinglist.length; _i < _len; _i++) {
              binding = bindinglist[_i];
              property = binding.property;
              boundref.bind(property, constraint.callback);
              constraint.callbackbindings.push(property, boundref);
            }
          }
          this.setAttribute(name, fn(), false, false, true);
        }
      };

      Node.prototype._bindHandlers = function(isLate) {
        var binding, bindings, callback, defer, ev, name, reference, refeval, scope, _i, _len;
        bindings = isLate ? this.latehandlers : this.handlers;
        if (!bindings) {
          return;
        }
        defer = [];
        for (_i = 0, _len = bindings.length; _i < _len; _i++) {
          binding = bindings[_i];
          scope = binding.scope, name = binding.name, ev = binding.ev, callback = binding.callback, reference = binding.reference;
          if (reference) {
            refeval = this._valueLookup(reference)();
            if (refeval instanceof Eventable) {
              scope.listenTo(refeval, ev, callback);
            } else {
              defer.push(binding);
              continue;
            }
          } else {
            scope.bind(ev, callback);
            if (ev in scope) {
              scope.sendEvent(ev, scope[ev]);
            }
          }
        }
        if (defer.length) {
          if (isLate) {
            this.latehandlers = defer;
          } else {
            this.handlers = defer;
          }
          setTimeout((function(_this) {
            return function() {
              return _this._bindHandlers(isLate);
            };
          })(this), 0);
          return;
        }
        if (isLate) {
          this.latehandlers = [];
        } else {
          this.handlers = [];
        }
      };

      Node.prototype._constraintCallback = function(name, fn) {
        return (function constraintCallback(){;
        this.setAttribute(name, fn(), false, false, true);
        return }).bind(this);
      };

      Node.prototype.set_parent = function(parent) {
        if (parent instanceof Node) {
          if (this.name) {
            parent[this.name] = this;
          }
          return parent.subnodes.push(this);
        }
      };

      Node.prototype.set_name = function(name) {
        if (this.parent && name) {
          return this.parent[name] = this;
        }
      };

      Node.prototype.set_id = function(id) {
        return window[id] = this;
      };

      Node.prototype._removeFromParent = function(name) {
        var arr, index, removedNode;
        if (!this.parent) {
          return;
        }
        arr = this.parent[name];
        index = arr.indexOf(this);
        if (index !== -1) {
          removedNode = arr[index];
          arr.splice(index, 1);
          this.parent.sendEvent(name, removedNode);
          if (name === 'subnodes') {

            /**
             * @event subnodeRemoved
             * Fired when a subnode is removed from this node.
             * @param {dr.node} node The dr.node that was removed
             */
            this.parent.sendEvent('subnodeRemoved', removedNode);
            this.parent.doSubnodeRemoved(removedNode);
          }
        }
      };

      Node.prototype._findParents = function(name, value) {
        var out, p;
        out = [];
        p = this;
        while (p) {
          if (name in p && p[name] === value) {
            out.push(p);
          }
          p = p.parent;
        }
        return out;
      };

      Node.prototype._findInParents = function(name) {
        var p;
        p = this.parent;
        while (p) {
          if (name in p) {
            return p[name];
          }
          p = p.parent;
        }
      };


      /**
       * Called when a subnode is added to this node. Provides a hook for
       * subclasses. No need for subclasses to call super. Do not call this
       * method to add a subnode. Instead call setParent.
       * @param {dr.node} node The subnode that was added.
       * @return {void}
       */

      Node.prototype.doSubnodeAdded = function(node) {};


      /**
       * Called when a subnode is removed from this node. Provides a hook for
       * subclasses. No need for subclasses to call super. Do not call this
       * method to remove a subnode. Instead call _removeFromParent.
       * @param {dr.node} node The subnode that was removed.
       * @return {void}
       */

      Node.prototype.doSubnodeRemoved = function(node) {};


      /**
       * @method destroy
       * Destroys this node
       */


      /**
       * @ignore
       */

      Node.prototype.destroy = function(skipevents) {

        /**
         * @event ondestroy
         * Fired when this node and all its children are about to be destroyed
         * @param {dr.node} node The dr.node that fired the event
         */
        var property, subnode, _i, _len, _ref, _ref1;
        this.sendEvent('destroy', this);
        if (this.constraints) {
          for (property in this.constraints) {
            this._unbindConstraint(property);
          }
        }
        if (this.listeningTo) {
          this.stopListening();
        }
        this.unbind();
        if (((_ref = this.parent) != null ? _ref[this.name] : void 0) === this) {
          delete this.parent[this.name];
        }
        _ref1 = this.subnodes;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          subnode = _ref1[_i];
          if (subnode != null) {
            subnode.destroy(true);
          }
        }
        if (!skipevents) {
          return this._removeFromParent('subnodes');
        }
      };

      return Node;

    })(Eventable);

    /**
     * @class Sprite
     * @private
     * Abstracts the underlying visual primitives (currently HTML) from dreem's view system.
     */
    Sprite = (function() {
      var noop, styleval;

      noop = function() {};

      styleval = {
        display: function(isVisible) {
          if (isVisible) {
            return '';
          } else {
            return 'none';
          }
        },
        cursor: function(clickable) {
          if (clickable) {
            return 'pointer';
          } else {
            return '';
          }
        }
      };

      function Sprite(jqel, view, tagname) {
        if (tagname == null) {
          tagname = 'div';
        }
        this.handle = __bind(this.handle, this);
        this.animate = __bind(this.animate, this);
        if (jqel == null) {
          this.el = document.createElement(tagname);
          this.el.$init = true;
        } else if (jqel instanceof HTMLElement) {
          this.el = jqel;
        }
        this.el.$view = view;
        this.el.setAttribute('class', 'sprite');
      }

      Sprite.prototype.setStyle = function(name, value, internal, el) {
        if (el == null) {
          el = this.el;
        }
        if (value == null) {
          value = '';
        }
        if (name in stylemap) {
          name = stylemap[name];
        }
        if (name in styleval) {
          value = styleval[name](value);
        }
        return el.style[name] = value;
      };

      Sprite.prototype.set_parent = function(parent) {
        if (parent instanceof Sprite) {
          parent = parent.el;
        }
        return parent.appendChild(this.el);
      };

      Sprite.prototype.set_id = function(id) {
        return this.el.setAttribute('id', id);
      };

      Sprite.prototype.animate = function() {
        var name, value, _ref;
        if (this.jqel == null) {
          this.jqel = $(this.el);
        }
        _ref = arguments[0];
        for (name in _ref) {
          value = _ref[name];
          if (name in stylemap) {
            arguments[0][stylemap[name]] = value;
            delete arguments[0][name];
          }
        }
        return this.jqel.animate.apply(this.jqel, arguments);
      };

      Sprite.prototype.set_clickable = function(clickable) {
        this.__clickable = clickable;
        this.__updatePointerEvents();
        return this.setStyle('cursor', clickable, true);
      };

      Sprite.prototype.set_clip = function(clip) {
        this.__clip = clip;
        return this.__updateOverflow();
      };

      Sprite.prototype.set_scrollable = function(scrollable) {
        this.__scrollable = scrollable;
        this.__updateOverflow();
        return this.__updatePointerEvents();
      };

      Sprite.prototype.__updateOverflow = function() {
        return this.setStyle('overflow', this.__scrollable ? 'auto' : this.__clip ? 'hidden' : '', true);
      };

      Sprite.prototype.__updatePointerEvents = function() {
        return this.setStyle('pointer-events', this.__clickable || this.__scrollable ? 'auto' : 'none', true);
      };

      Sprite.prototype.destroy = function() {
        this.el.parentNode.removeChild(this.el);
        return this.el = this.jqel = null;
      };

      Sprite.prototype.setText = function(txt) {
        if (txt != null) {
          return this.el.innerHTML = txt;
        }
      };

      Sprite.prototype.getText = function(textOnly) {
        if (textOnly) {
          return this.el.innerText;
        } else {
          return this.el.innerHTML;
        }
      };

      Sprite.prototype.value = function(value) {
        if (!this.input) {
          return;
        }
        if (value != null) {
          return this.input.value = value;
        } else {
          return this.input.value;
        }
      };

      Sprite.prototype.measureTextSize = function(multiline, width, resize) {
        if (multiline) {
          this.setStyle('width', width, true);
          this.setStyle('height', 'auto', true);
          this.setStyle('whiteSpace', 'normal', true);
        } else {
          if (resize) {
            this.setStyle('width', 'auto', true);
            this.setStyle('height', 'auto', true);
          }
          this.setStyle('whiteSpace', '', true);
        }
        return {
          width: this.el.clientWidth,
          height: this.el.clientHeight
        };
      };

      Sprite.prototype.handle = function(event) {
        var view;
        view = event.target.$view;
        if (!view) {
          return;
        }
        return view.sendEvent(event.type, view);
      };

      Sprite.prototype.createTextElement = function() {
        return this.el.setAttribute('class', 'sprite sprite-text noselect');
      };

      Sprite.prototype.createInputtextElement = function(text, multiline, width, height) {
        var input;
        this.el.setAttribute('class', 'sprite noselect');
        if (multiline) {
          input = document.createElement('textarea');
        } else {
          input = document.createElement('input');
          input.setAttribute('type', 'text');
        }
        input.setAttribute('value', text);
        input.setAttribute('class', 'sprite-inputtext');
        if (width) {
          this.setStyle('width', width, true, input);
        }
        if (height) {
          this.setStyle('height', height, true, input);
        }
        this.el.appendChild(input);
        input.$view = this.el.$view;
        $(input).on('focus blur', this.handle);
        return this.input = input;
      };

      Sprite.prototype.getAbsolute = function() {
        var pos;
        if (this.jqel == null) {
          this.jqel = $(this.el);
        }
        pos = this.jqel.offset();
        return {
          x: pos.left - window.pageXOffset,
          y: pos.top - window.pageYOffset
        };
      };

      Sprite.prototype.set_class = function(classname) {
        return this.el.setAttribute('class', classname);
      };

      return Sprite;

    })();
    if (capabilities.camelcss) {
      ss = Sprite.prototype.setStyle;
      fcamelCase = function(all, letter) {
        return letter.toUpperCase();
      };
      rdashAlpha = /-([\da-z])/gi;
      Sprite.prototype.setStyle = function(name, value, internal, el) {
        if (el == null) {
          el = this.el;
        }
        if (name.match(rdashAlpha)) {
          name = name.replace(rdashAlpha, fcamelCase);
        }
        return ss(name, value, internal, el);
      };
    }
    if (debug) {
      otherstyles = ['width', 'height', 'background-color'];
      ss2 = Sprite.prototype.setStyle;
      Sprite.prototype.setStyle = function(name, value, internal, el) {
        if (el == null) {
          el = this.el;
        }
        if (!internal && !(name in stylemap) && !(__indexOf.call(otherstyles, name) >= 0)) {
          console.warn("Setting unknown CSS property " + name + " = " + value + " on ", this.el.$view, stylemap, internal);
        }
        return ss2(name, value, internal, el);
      };
    }
    hiddenAttributes = {
      text: true,
      $tagname: true,
      data: true,
      replicator: true,
      "class": true,
      clip: true,
      clickable: true,
      scrollable: true,
      $textcontent: true,
      resize: true,
      multiline: true,
      ignorelayout: true
    };
    ignoredAttributes = {
      parent: true,
      id: true,
      name: true,
      "extends": true,
      type: true,
      scriptincludes: true
    };

    /**
     * @aside guide constraints
     * @class dr.view {UI Components}
     * @extends dr.node
     * The visual base class for everything in dreem. Views extend dr.node to add the ability to set and animate visual attributes, and interact with the mouse.
     *
     * Views are positioned inside their parent according to their x and y coordinates.
     *
     * Views can contain methods, handlers, setters, constraints, attributes and other view, node or class instances.
     *
     * Views can be easily converted to reusable classes/tags by changing their outermost &lt;view> tags to &lt;class> and adding a name attribute.
     *
     * Views support a number of builtin attributes. Setting attributes that aren't listed explicitly will pass through to the underlying Sprite implementation.
     *
     * Views currently integrate with jQuery, so any changes made to their CSS via jQuery will automatically cause them to update.
     *
     * Note that dreem apps must be contained inside a top-level &lt;view>&lt;/view> tag.
     *
     * The following example shows a pink view that contains a smaller blue view offset 10 pixels from the top and 10 from the left.
     *
     *     @example
     *     <view width="200" height="100" bgcolor="lightpink">
     *
     *       <view width="50" height="50" x="10" y="10" bgcolor="lightblue"></view>
     *
     *     </view>
     *
     * Here the blue view is wider than its parent pink view, and because the clip attribute of the parent is set to false it extends beyond the parents bounds.
     *
     *     @example
     *     <view width="200" height="100" bgcolor="lightpink" clip="false">
     *
     *       <view width="250" height="50" x="10" y="10" bgcolor="lightblue"></view>
     *
     *     </view>
     *
     * Now we set the clip attribute on the parent view to true, causing the overflowing child view to be clipped at its parent's boundary.
     *
     *     @example
     *     <view width="200" height="100" bgcolor="lightpink" clip="true">
     *
     *       <view width="250" height="50" x="10" y="10" bgcolor="lightblue"></view>
     *
     *     </view>
     *
     * Here we demonstrate how unsupported attributes are passed to the underlying sprite system. We make the child view semi-transparent by setting opacity. Although this is not in the list of supported attributes it is still applied.
     *
     *     @example
     *     <view width="200" height="100" bgcolor="lightpink">
     *
     *       <view width="250" height="50" x="10" y="10" bgcolor="lightblue" opacity=".5"></view>
     *
     *     </view>
     *
     * It is convenient to [constrain](#!/guide/constraints) a view's size and position to attributes of its parent view. Here we'll position the inner view so that its inset by 10 pixels in its parent.
     *
     *     @example
     *     <view width="200" height="100" bgcolor="lightpink">
     *
     *       <view width="${this.parent.width-this.inset*2}" height="${this.parent.height-this.inset*2}" x="${this.inset}" y="${this.inset}" bgcolor="lightblue">
     *         <attribute name="inset" type="number" value="10"></attribute>
     *       </view>
     *
     *     </view>
     */
    View = (function(_super) {
      __extends(View, _super);


      /**
       * @attribute {Number} [x=0]
       * This view's x position
       */


      /**
       * @attribute {Number} [y=0]
       * This view's y position
       */


      /**
       * @attribute {Number} [width=0]
       * This view's width
       */


      /**
       * @attribute {Number} [height=0]
       * This view's height
       */


      /**
       * @attribute {Boolean} [clickable=false]
       * If true, this view recieves mouse events. Automatically set to true when an onclick/mouse* event is registered for this view.
       */


      /**
       * @attribute {Boolean} [clip=false]
       * If true, this view clips to its bounds
       */


      /**
       * @attribute {Boolean} [scrollable=false]
       * If true, this view clips to its bounds and provides scrolling to see content that overflows the bounds
       */


      /**
       * @attribute {Boolean} [visible=true]
       * If false, this view is invisible
       */


      /**
       * @attribute {String} bgcolor
       * Sets this view's background color
       */


      /**
       * @attribute {String} bordercolor
       * Sets this view's border color
       */


      /**
       * @attribute {String} borderstyle
       * Sets this view's border style (can be any css border-style value)
       */


      /**
       * @attribute {Number} border
       * Sets this view's border width
       */


      /**
       * @attribute {Number} padding
       * Sets this view's padding
       */


      /**
       * @event onclick
       * Fired when this view is clicked
       * @param {dr.view} view The dr.view that fired the event
       */


      /**
       * @event onmouseover
       * Fired when the mouse moves over this view
       * @param {dr.view} view The dr.view that fired the event
       */


      /**
       * @event onmouseout
       * Fired when the mouse moves off this view
       * @param {dr.view} view The dr.view that fired the event
       */


      /**
       * @event onmousedown
       * Fired when the mouse goes down on this view
       * @param {dr.view} view The dr.view that fired the event
       */


      /**
       * @event onmouseup
       * Fired when the mouse goes up on this view
       * @param {dr.view} view The dr.view that fired the event
       */

      function View(el, attributes) {
        var defaults, key, type, types, _ref;
        if (attributes == null) {
          attributes = {};
        }

        /**
         * @property {dr.view[]} subviews
         * @readonly
         * An array of this views's child views
         */

        /**
         * @event onsubviews
         * Fired when this views's subviews array has changed
         * @param {dr.view} view The dr.view that fired the event
         */

        /**
         * @property {dr.layout[]} layouts
         * @readonly
         * An array of this views's layouts. Only defined when needed.
         */

        /**
         * @event onlayouts
         * Fired when this views's layouts array has changed
         * @param {dr.layout} view The dr.layout that fired the event
         */

        /**
         * @property {Boolean} ignorelayout
         * If true, layouts should ignore this view
         */
        this.subviews = [];
        types = {
          x: 'number',
          y: 'number',
          width: 'number',
          height: 'number',
          clickable: 'boolean',
          clip: 'boolean',
          scrollable: 'boolean',
          visible: 'boolean',
          border: 'number',
          padding: 'number'
        };
        defaults = {
          x: 0,
          y: 0,
          width: 0,
          height: 0,
          clickable: false,
          clip: false,
          scrollable: false,
          visible: true,
          bordercolor: 'transparent',
          borderstyle: 'solid',
          border: 0,
          padding: 0
        };
        _ref = attributes.$types;
        for (key in _ref) {
          type = _ref[key];
          types[key] = type;
        }
        attributes.$types = types;
        this._setDefaults(attributes, defaults);
        if (el instanceof View) {
          el = el.sprite;
        }
        this._createSprite(el, attributes);
        View.__super__.constructor.apply(this, arguments);
      }

      View.prototype._isPercent = function(value) {
        return typeof value === 'string' && value.indexOf('%') > -1;
      };

      View.prototype._createSprite = function(el, attributes) {
        return this.sprite = new Sprite(el, this, attributes.$tagname);
      };

      View.prototype.setAttribute = function(name, value, skipstyle, skipConstraintSetup, skipconstraintunregistration) {
        if (!skipConstraintSetup) {
          switch (name) {
            case 'width':
            case 'x':
              if (this.__setupPercentConstraint(name, value, 'innerwidth')) {
                return;
              }
              break;
            case 'height':
            case 'y':
              if (this.__setupPercentConstraint(name, value, 'innerheight')) {
                return;
              }
          }
        }
        value = this._coerceType(name, value);
        switch (name) {
          case 'width':
          case 'height':
          case 'border':
          case 'padding':
            value = Math.max(0, value);
        }
        if (!(skipstyle || name in ignoredAttributes || name in hiddenAttributes || this[name] === value)) {
          this.sprite.setStyle(name, value);
        }
        return View.__super__.setAttribute.call(this, name, value, true, skipConstraintSetup, skipconstraintunregistration);
      };

      View.prototype.__setupPercentConstraint = function(name, value, axis) {
        var func, funcKey, oldFunc, parent, scale, self;
        funcKey = '__percentFunc' + name;
        oldFunc = this[funcKey];
        parent = this.parent;
        if (!(parent instanceof Node)) {
          parent = dr.window;
          axis = axis.substring(5);
        }
        if (oldFunc) {
          this.stopListening(parent, axis, oldFunc);
          delete this[funcKey];
        }
        if (this._isPercent(value)) {
          self = this;
          scale = parseInt(value) / 100;
          func = this[funcKey] = function() {
            return self.setAttribute(name, parent[axis] * scale, false, true);
          };
          this.listenTo(parent, axis, func);
          func.call();
          return true;
        }
      };

      View.prototype.set_width = function(width) {
        return this.setAttribute('innerwidth', width - 2 * (this.border + this.padding), true);
      };

      View.prototype.set_height = function(height) {
        return this.setAttribute('innerheight', height - 2 * (this.border + this.padding), true);
      };

      View.prototype.set_border = function(border) {
        return this.__updateInnerMeasures(2 * (border + this.padding));
      };

      View.prototype.set_padding = function(padding) {
        return this.__updateInnerMeasures(2 * (this.border + padding));
      };

      View.prototype.__updateInnerMeasures = function(inset) {
        this.innerwidth = this.width - inset;
        this.innerheight = this.height - inset;
        this.setAttribute('innerwidth', this.width - inset, true);
        return this.setAttribute('innerheight', this.height - inset, true);
      };

      View.prototype.set_clickable = function(clickable) {
        return this.sprite.set_clickable(clickable);
      };

      View.prototype.set_parent = function(parent) {
        View.__super__.set_parent.apply(this, arguments);
        if (parent instanceof View) {
          parent.subviews.push(this);
          parent.sendEvent('subviews', this);
          parent = parent.sprite;
        }
        return this.sprite.set_parent(parent);
      };

      View.prototype.set_id = function(id) {
        View.__super__.set_id.apply(this, arguments);
        return this.sprite.set_id(id);
      };


      /**
       * Animates this view's attribute(s)
       * @param {Object} obj A hash of attribute names and values to animate to
       * @param Number duration The duration of the animation in milliseconds
       */

      View.prototype.animate = function() {
        this.sprite.animate.apply(this, arguments);
        return this;
      };

      View.prototype.set_clip = function(clip) {
        return this.sprite.set_clip(clip);
      };

      View.prototype.set_scrollable = function(scrollable) {
        return this.sprite.set_scrollable(scrollable);
      };


      /**
       * Calls doSubviewAdded/doLayoutAdded if the added subnode is a view or
       * layout respectively. Subclasses should call super.
       */

      View.prototype.doSubnodeAdded = function(node) {
        if (node instanceof View) {

          /**
           * @event subviewAdded
           * Fired when a subview is added to this view.
           * @param {dr.view} view The dr.view that was added
           */
          this.sendEvent('subviewAdded', node);
          return this.doSubviewAdded(node);
        } else if (node instanceof Layout) {

          /**
           * @event layoutAdded
           * Fired when a layout is added to this view.
           * @param {dr.layout} layout The dr.layout that was added
           */
          this.sendEvent('layoutAdded', node);
          return this.doLayoutAdded(node);
        }
      };


      /**
       * Calls doSubviewRemoved/doLayoutRemoved if the removed subnode is a view or
       * layout respectively. Subclasses should call super.
       */

      View.prototype.doSubnodeRemoved = function(node) {
        if (node instanceof View) {

          /**
           * @event subviewRemoved
           * Fired when a subview is removed from this view.
           * @param {dr.view} view The dr.view that was removed
           */
          this.sendEvent('subviewRemoved', node);
          return this.doSubviewRemoved(node);
        } else if (node instanceof Layout) {

          /**
           * @event layoutRemoved
           * Fired when a layout is removed from this view.
           * @param {dr.layout} layout The dr.layout that was removed
           */
          this.sendEvent('layoutRemoved', node);
          return this.doLayoutRemoved(node);
        }
      };


      /**
       * Called when a subview is added to this view. Provides a hook for
       * subclasses. No need for subclasses to call super. Do not call this
       * method to add a subview. Instead call setParent.
       * @param {dr.view} sv The subview that was added.
       * @return {void}
       */

      View.prototype.doSubviewAdded = function(sv) {};


      /**
       * Called when a subview is removed from this view. Provides a hook for
       * subclasses. No need for subclasses to call super. Do not call this
       * method to remove a subview. Instead call _removeFromParent.
       * @param {dr.view} sv The subview that was removed.
       * @return {void}
       */

      View.prototype.doSubviewRemoved = function(sv) {};


      /**
       * Called when a layout is added to this view. Provides a hook for
       * subclasses. No need for subclasses to call super. Do not call this
       * method to add a layout. Instead call setParent.
       * @param {dr.layout} layout The layout that was added.
       * @return {void}
       */

      View.prototype.doLayoutAdded = function(layout) {};


      /**
       * Called when a layout is removed from this view. Provides a hook for
       * subclasses. No need for subclasses to call super. Do not call this
       * method to remove a layout. Instead call _removeFromParent.
       * @param {dr.layout} layout The layout that was removed.
       * @return {void}
       */

      View.prototype.doLayoutRemoved = function(layout) {};

      View.prototype.destroy = function(skipevents) {
        View.__super__.destroy.apply(this, arguments);
        if (!skipevents) {
          this._removeFromParent('subviews');
        }
        this.sprite.destroy();
        return this.sprite = null;
      };

      View.prototype.getAbsolute = function() {
        return this.sprite.getAbsolute();
      };

      View.prototype.set_class = function(classname) {
        return this.sprite.set_class(classname);
      };

      return View;

    })(Node);

    /**
     * @class dr.inputtext {UI Components, Input}
     * @extends dr.view
     * Provides an editable input text field.
     *
     *     @example
     *     <spacedlayout axis="y"></spacedlayout>
     *
     *     <text text="Enter your name"></text>
     *
     *     <inputtext id="nameinput" bgcolor="white" border="1px solid lightgrey" width="200"></inputtext>
     *
     *     <labelbutton text="submit">
     *       <handler event="onclick">
     *         welcome.setAttribute('text', 'Welcome ' + nameinput.text);
     *       </handler>
     *     </labelbutton>
     *
     *     <text id="welcome"></text>
     *
     * It's possible to listen for an onchange event to find out when the user changed the inputtext value:
     *
     *     @example
     *     <inputtext id="nameinput" bgcolor="white" border="1px solid lightgrey" width="200" onchange="console.log('onchange', this.text)"></inputtext>
     *
     */
    InputText = (function(_super) {
      __extends(InputText, _super);


      /**
       * @attribute {Boolean} [multiline=false]
       * Set to true to show multi-line text.
       */


      /**
       * @attribute {String} text
       * The text inside this input text field
       */


      /**
       * @attribute {Number} [width=100]
       * The width of this input text field
       */

      function InputText(el, attributes) {
        var defaults, key, type, types, _ref;
        if (attributes == null) {
          attributes = {};
        }
        types = {
          multiline: 'boolean'
        };
        defaults = {
          clickable: true,
          multiline: false,
          width: 100
        };
        _ref = attributes.$types;
        for (key in _ref) {
          type = _ref[key];
          types[key] = type;
        }
        attributes.$types = types;
        this._setDefaults(attributes, defaults);
        InputText.__super__.constructor.apply(this, arguments);
        if (!this.height) {
          this.setAttribute('height', this._getDefaultHeight());
        }
        this.listenTo(this, 'change', this._handleChange);
        this.listenTo(this, 'innerwidth', function(iw) {
          return this.sprite.setStyle('width', iw, true, this.sprite.input);
        });
        this.sprite.setStyle('width', this.innerwidth, true, this.sprite.input);
        this.listenTo(this, 'innerheight', function(ih) {
          return this.sprite.setStyle('height', ih, true, this.sprite.input);
        });
        this.sprite.setStyle('height', this.innerheight, true, this.sprite.input);
        this.listenTo(this, 'click', function() {
          return this.sprite.input.focus();
        });
      }

      InputText.prototype._createSprite = function(el, attributes) {
        var multiline;
        InputText.__super__._createSprite.apply(this, arguments);
        attributes.text || (attributes.text = this.sprite.getText(true));
        this.sprite.setText('');
        multiline = this._coerceType('multiline', attributes.multiline, 'boolean');
        return this.sprite.createInputtextElement('', multiline, attributes.width, attributes.height);
      };

      InputText.prototype._getDefaultHeight = function() {
        var borderH, domElem, h, paddingH;
        h = parseInt($(this.sprite.input).css('height'));
        domElem = $(this.sprite.el);
        borderH = parseInt(domElem.css('border-top-width')) + parseInt(domElem.css('border-bottom-width'));
        paddingH = parseInt(domElem.css('padding-top')) + parseInt(domElem.css('padding-bottom'));
        return h + borderH + paddingH;
      };

      InputText.prototype._handleChange = function() {
        var newdata;
        if (!this.replicator) {
          return;
        }
        newdata = this.text;
        if (typeof this.data === 'number') {
          if (parseFloat(newdata) + '' === newdata) {
            newdata = parseFloat(newdata);
          }
        } else if (typeof this.data === 'boolean') {
          if (newdata === 'true') {
            newdata = true;
          } else if (newdata === 'false') {
            newdata = false;
          }
        }
        return this.replicator.updateData(newdata);
      };

      InputText.prototype.set_data = function(d) {
        return this.setAttribute('text', d, true);
      };

      InputText.prototype.set_text = function(text) {
        return this.sprite.value(text);
      };

      return InputText;

    })(View);

    /**
     * @class dr.text {UI Components}
     * @extends dr.view
     * Text component that supports single and multi-line text.
     *
     * The text component can be fixed size, or sized to fit the size of the text.
     *
     *     @example
     *     <text text="Hello World!" bgcolor="red"></text>
     *
     * Here is a multiline text
     *
     *     @example
     *     <text multiline="true" text="Lorem ipsum dolor sit amet, consectetur adipiscing elit"></text>
     *
     * You might want to set the value of a text element based on the value of other attributes via a constraint. Here we set the value by concatenating three attributes together.
     *
     *     @example
     *     <attribute name="firstName" type="string" value="Lumpy"></attribute>
     *     <attribute name="middleName" type="string" value="Space"></attribute>
     *     <attribute name="lastName" type="string" value="Princess"></attribute>
     *
     *     <text text="${this.parent.firstName + ' ' + this.parent.middleName + ' ' + this.parent.lastName}" color="hotpink"></text>
     *
     * Constraints can contain more complex JavaScript code
     *
     *     @example
     *     <attribute name="firstName" type="string" value="Lumpy"></attribute>
     *     <attribute name="middleName" type="string" value="Space"></attribute>
     *     <attribute name="lastName" type="string" value="Princess"></attribute>
     *
     *     <text text="${this.parent.firstName.charAt(0) + ' ' + this.parent.middleName.charAt(0) + ' ' + this.parent.lastName.charAt(0)}" color="hotpink"></text>
     *
     * We can simplify this by using a method to return the concatenation and constraining the text value to the return value of the method
     *
     *     @example
     *     <attribute name="firstName" type="string" value="Lumpy"></attribute>
     *     <attribute name="middleName" type="string" value="Space"></attribute>
     *     <attribute name="lastName" type="string" value="Princess"></attribute>
     *
     *     <method name="initials">
     *       return this.firstName.charAt(0) + ' ' + this.middleName.charAt(0) + ' ' + this.lastName.charAt(0);
     *     </method>
     *
     *     <text text="${this.parent.initials()}" color="hotpink"></text>
     *
     * You can override the format method to provide custom formatting for text elements. Here is a subclass of text, timetext, with the format method overridden to convert the text given in seconds into a formatted string.
     *
     *     @example
     *     <class name="timetext" extends="text">
     *       <method name="format" args="seconds">
     *         var minutes = Math.floor(seconds / 60);
     *         var seconds = Math.floor(seconds) - minutes * 60;
     *         if (seconds < 10) {
     *           seconds = '0' + seconds;
     *         }
     *         return minutes + ':' + seconds;
     *       </method>
     *     </class>
     *
     *     <timetext text="240"></timetext>
     *
     */
    Text = (function(_super) {
      __extends(Text, _super);


      /**
       * @attribute {Boolean} [multiline=false]
       * Set to true to show multi-line text.
       */


      /**
       * @attribute {Boolean} [resize=true]
       * By default, the text component is sized to the size of the text.
       * By setting resize=false, the component size is not modified
       * when the text changes.
       */


      /**
       * @attribute {String} [text=""]
       * Component text.
       */

      function Text(el, attributes) {
        var defaults, key, type, types, _ref;
        if (attributes == null) {
          attributes = {};
        }
        types = {
          resize: 'boolean',
          multiline: 'boolean'
        };
        defaults = {
          resize: true,
          multiline: false
        };
        _ref = attributes.$types;
        for (key in _ref) {
          type = _ref[key];
          types[key] = type;
        }
        attributes.$types = types;
        this._setDefaults(attributes, defaults);
        if ('width' in attributes) {
          this._initialwidth = attributes.width;
        }
        this.listenTo(this, 'multiline', this.updateSize);
        this.listenTo(this, 'resize', this.updateSize);
        this.listenTo(this, 'init', this.updateSize);
        Text.__super__.constructor.apply(this, arguments);
      }

      Text.prototype._createSprite = function(el, attributes) {
        Text.__super__._createSprite.apply(this, arguments);
        attributes.text || (attributes.text = this.sprite.getText(true));
        return this.sprite.createTextElement();
      };


      /**
       * @method format
       * Format the text to be displayed. The default behavior is to
       * return the text intact. Override to change formatting.
       * @param {String} str The current value of the text component.
       * @return {String} The formated string to display in the component.
       *
       */

      Text.prototype.format = function(str) {
        return str;
      };

      Text.prototype.updateSize = function() {
        var parent, parents, size, width, _i, _j, _len, _len1;
        if (!this.inited) {
          return;
        }
        width = this.multiline ? this._initialwidth : this.width;
        size = this.sprite.measureTextSize(this.multiline, width, this.resize);
        if (size.width === 0 && size.height === 0) {
          parents = this._findParents('visible', false);
          for (_i = 0, _len = parents.length; _i < _len; _i++) {
            parent = parents[_i];
            parent.sprite.el.style.display = '';
          }
          size = this.sprite.measureTextSize(this.multiline, width, this.resize);
          for (_j = 0, _len1 = parents.length; _j < _len1; _j++) {
            parent = parents[_j];
            parent.sprite.el.style.display = 'none';
          }
        }
        this.setAttribute('width', size.width, true);
        return this.setAttribute('height', size.height, true);
      };

      Text.prototype.set_data = function(d) {
        return this.setAttribute('text', d, true);
      };

      Text.prototype.set_text = function(text) {
        if (text !== this.text) {
          this.sprite.setText(this.format(text));
          return this.updateSize();
        }
      };

      return Text;

    })(View);
    warnings = [];
    showWarnings = function(data) {
      var out, pre;
      warnings = warnings.concat(data);
      out = data.join('\n');
      pre = document.createElement('pre');
      pre.setAttribute('class', 'warnings');
      pre.textContent = out;
      document.body.insertBefore(pre, document.body.firstChild);
      return console.error(out);
    };
    dom = (function() {
      var builtinTags, checkRequiredAttributes, exports, findAutoIncludes, flattenattributes, getChildren, htmlDecode, initAllElements, initElement, initFromElement, processSpecialTags, requiredAttributes, sendInit, specialtags, writeCSS;
      getChildren = function(el) {
        var child, _i, _len, _ref, _ref1, _results;
        _ref = el.childNodes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.nodeType === 1 && (_ref1 = child.localName, __indexOf.call(specialtags, _ref1) >= 0)) {
            _results.push(child);
          }
        }
        return _results;
      };
      flattenattributes = function(namednodemap) {
        var attributes, i, _i, _len;
        attributes = {};
        for (_i = 0, _len = namednodemap.length; _i < _len; _i++) {
          i = namednodemap[_i];
          attributes[i.name] = i.value;
        }
        return attributes;
      };
      sendInit = function() {
        var event;
        event = document.createEvent('Event');
        event.initEvent('dreeminit', true, true);
        return window.dispatchEvent(event);
      };
      initFromElement = function(el) {
        el.style.display = 'none';
        return findAutoIncludes(el, function() {
          el.style.display = null;
          initElement(el);
          _initConstraints();
          window.DREEM_INITED = true;
          return sendInit();
        });
      };
      findAutoIncludes = function(parentel, finalcallback) {
        var fileloaded, filereloader, filerequests, findIncludeURLs, findMissingClasses, includedScripts, inlineclasses, jqel, loadInclude, loadIncludes, loadScript, loadqueue, scriptloading, validator;
        jqel = $(parentel);
        includedScripts = {};
        loadqueue = [];
        scriptloading = false;
        loadScript = function(url, cb, error) {
          var appendScript, appendcallback;
          if (url in includedScripts) {
            return;
          }
          includedScripts[url] = true;
          if (scriptloading) {
            loadqueue.push(url, error);
            return url;
          }
          appendScript = function(url, cb, error) {
            var script;
            if (error == null) {
              error = 'failed to load scriptinclude ' + url;
            }
            scriptloading = url;
            script = document.createElement('script');
            script.type = 'text/javascript';
            $('head').append(script);
            script.onload = cb;
            script.onerror = function(err) {
              console.error(error, err);
              return cb();
            };
            return script.src = url;
          };
          appendcallback = function() {
            scriptloading = false;
            if (loadqueue.length === 0) {
              return cb();
            } else {
              return appendScript(loadqueue.shift(), appendcallback, loadqueue.shift());
            }
          };
          return appendScript(url, appendcallback, error);
        };
        inlineclasses = {};
        filerequests = [];
        fileloaded = {};
        loadInclude = function(url, el) {
          var prom;
          if (url in fileloaded) {
            return;
          }
          fileloaded[url] = el;
          prom = $.get(url);
          prom.url = url;
          prom.el = el;
          return filerequests.push(prom);
        };
        findMissingClasses = function(names) {
          var el, name, out, _i, _len, _ref, _ref1, _ref2;
          if (names == null) {
            names = {};
          }
          _ref = jqel.find('*');
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            el = _ref[_i];
            name = el.localName;
            if (name === 'class') {
              if (el.attributes["extends"]) {
                names[el.attributes["extends"].value] = el;
              }
              inlineclasses[(_ref1 = el.attributes.name) != null ? _ref1.value : void 0] = true;
            } else if (name === 'replicator') {
              names[name] = el;
              names[el.attributes.classname.value] = el;
            } else {
              if (_ref2 = el.parentNode.localName, __indexOf.call(specialtags, _ref2) < 0) {
                names[name] = el;
              }
            }
          }
          out = {};
          for (name in names) {
            el = names[name];
            if (!(name in dr || name in fileloaded || __indexOf.call(specialtags, name) >= 0 || name in inlineclasses || __indexOf.call(builtinTags, name) >= 0)) {
              out[name] = el;
            }
          }
          return out;
        };
        findIncludeURLs = function(urls) {
          var el, url, _i, _len, _ref;
          if (urls == null) {
            urls = {};
          }
          _ref = jqel.find('include');
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            el = _ref[_i];
            url = el.attributes.href.value;
            el.parentNode.removeChild(el);
            urls[url] = el;
          }
          return urls;
        };
        loadIncludes = function(callback) {
          var el, url, _ref;
          _ref = findIncludeURLs();
          for (url in _ref) {
            el = _ref[url];
            loadInclude(url, el);
          }
          return $.when.apply($, filerequests).done(function() {
            var args, html, includeRE, name, xhr, _i, _len, _ref1;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            if (filerequests.length === 1) {
              args = [args];
            }
            filerequests = [];
            includeRE = /<[\/]*library>/gi;
            for (_i = 0, _len = args.length; _i < _len; _i++) {
              xhr = args[_i];
              html = xhr[0].replace(includeRE, '');
              jqel.prepend(html);
            }
            _ref1 = findMissingClasses();
            for (name in _ref1) {
              el = _ref1[name];
              fileloaded[name] = true;
              loadInclude("/classes/" + name + ".dre", el);
            }
            return $.when.apply($, filerequests).done(function() {
              var args, includes, oneurl, _j, _len1;
              args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              if (filerequests.length === 1) {
                args = [args];
              }
              filerequests = [];
              for (_j = 0, _len1 = args.length; _j < _len1; _j++) {
                xhr = args[_j];
                jqel.prepend(xhr[0]);
                if (debug) {
                  jqel.contents().each(function() {
                    if (this.nodeType === 8) {
                      return $(this).remove();
                    }
                  });
                }
              }
              includes = findMissingClasses(findIncludeURLs());
              if (Object.keys(includes).length > 0) {
                loadIncludes(callback);
                return;
              }
              oneurl = '/lib/one_base.js';
              return $.ajax({
                dataType: "script",
                cache: true,
                url: oneurl
              }).done(function() {
                var scriptloaded, _k, _l, _len2, _len3, _ref2, _ref3, _ref4;
                ONE.base_.call(Eventable.prototype);
                Eventable.prototype.enumfalse(Eventable.prototype.keys());
                Node.prototype.enumfalse(Node.prototype.keys());
                View.prototype.enumfalse(View.prototype.keys());
                Layout.prototype.enumfalse(Layout.prototype.keys());
                scriptloaded = false;
                _ref2 = jqel.find('[scriptincludes]');
                for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                  el = _ref2[_k];
                  _ref3 = el.attributes.scriptincludes.value.split(',');
                  for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
                    url = _ref3[_l];
                    scriptloaded = loadScript(url.trim(), callback, (_ref4 = el.attributes.scriptincludeserror) != null ? _ref4.value.toString() : void 0);
                  }
                }
                if (!scriptloaded) {
                  return callback();
                }
              }).fail(function() {
                return console.warn("failed to load " + oneurl);
              });
            }).fail(function() {
              var args, _j, _len1;
              args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              if (args.length === 1) {
                args = [args];
              }
              for (_j = 0, _len1 = args.length; _j < _len1; _j++) {
                xhr = args[_j];
                showWarnings(["failed to load " + xhr.url + " for element " + xhr.el.outerHTML]);
              }
            });
          }).fail(function() {
            var args, xhr, _i, _len;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            if (args.length === 1) {
              args = [args];
            }
            for (_i = 0, _len = args.length; _i < _len; _i++) {
              xhr = args[_i];
              showWarnings(["failed to load " + xhr.url + " for element " + xhr.el.outerHTML]);
            }
          });
        };
        filereloader = function() {
          return $.ajax({
            url: '/watchfile/',
            datatype: 'text',
            data: {
              url: window.location.pathname
            },
            success: function(data) {
              if (data === window.location.pathname) {
                return window.location.reload();
              }
            }
          }).done(function(data) {
            return filereloader();
          });
        };
        validator = function() {
          return $.ajax({
            url: '/validate/',
            data: {
              url: window.location.pathname
            },
            success: function(data) {
              if (data.length) {
                showWarnings(data);
              }
              return filereloader();
            },
            error: function(err) {
              return console.warn('Validation requires the Teem server');
            }
          }).always(finalcallback);
        };
        return loadIncludes(test ? finalcallback : validator);
      };
      specialtags = ['handler', 'method', 'attribute', 'setter', 'include'];
      builtinTags = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'command', 'datalist', 'dd', 'del', 'details', 'dfn', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'image', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'map', 'mark', 'menu', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr'];
      requiredAttributes = {
        "class": {
          "name": 1
        },
        "method": {
          "name": 1
        },
        "setter": {
          "name": 1
        },
        "handler": {
          "event": 1
        },
        "attribute": {
          "name": 1,
          "type": 1,
          "value": 1
        },
        "dataset": {
          "name": 1
        },
        "replicator": {
          "classname": 1
        }
      };
      checkRequiredAttributes = function(tagname, attributes, tag, parenttag) {
        var attrname, error;
        if (tagname in requiredAttributes) {
          for (attrname in requiredAttributes[tagname]) {
            if (!(attrname in attributes)) {
              error = "" + tagname + "." + attrname + " must be defined on " + tag.outerHTML;
              if (parenttag) {
                error = error + (" inside " + parenttag.outerHTML);
              }
              showWarnings([error]);
            }
          }
        }
        return error;
      };
      initElement = function(el, parent) {
        var attr, attributes, checkChildren, child, children, event, eventname, isClass, isState, li, skiponinit, tagname, _i, _j, _len, _len1;
        if (el.$init) {
          return;
        }
        el.$init = true;
        tagname = el.localName;
        if (__indexOf.call(specialtags, tagname) >= 0) {
          return;
        }
        if (!tagname in dr) {
          if (__indexOf.call(builtinTags, tagname) < 0) {
            console.warn('could not find class for tag', tagname, el);
          }
          return;
        } else if (__indexOf.call(builtinTags, tagname) >= 0) {
          if (tagname !== 'input') {
            console.warn('refusing to create a class that would overwrite the builtin tag', tagname);
          }
          return;
        }
        attributes = flattenattributes(el.attributes);
        checkRequiredAttributes(tagname, attributes, el);
        attributes.$tagname = tagname;
        for (_i = 0, _len = mouseEvents.length; _i < _len; _i++) {
          event = mouseEvents[_i];
          eventname = 'on' + event;
          if (eventname in attributes) {
            if (attributes.clickable !== false) {
              attributes.clickable = true;
            }
            el.removeAttribute(eventname);
          }
        }
        for (attr in attributes) {
          if (attr.indexOf('on') === 0) {
            el.removeAttribute(attr);
          }
        }
        if (parent == null) {
          parent = el.parentNode;
        }
        if (parent != null) {
          attributes.parent = parent;
        }
        li = tagname.lastIndexOf('state');
        isState = li > -1 && li === tagname.length - 5;
        isClass = tagname === 'class';
        if (!(isClass || isState)) {
          dom.processSpecialTags(el, attributes, attributes.type);
        }
        children = (function() {
          var _j, _len1, _ref, _results;
          _ref = el.childNodes;
          _results = [];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            child = _ref[_j];
            if (child.nodeType === 1) {
              _results.push(child);
            }
          }
          return _results;
        })();
        attributes.$skiponinit = skiponinit = children.length > 0;
        if (typeof dr[tagname] === 'function') {
          parent = new dr[tagname](el, attributes);
        } else {
          showWarnings(["Unrecognized class " + tagname + " " + el.outerHTML]);
          return;
        }
        if (!(children.length > 0)) {
          return;
        }
        if (!(isClass || isState)) {
          children = (function() {
            var _j, _len1, _ref, _results;
            _ref = el.childNodes;
            _results = [];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              child = _ref[_j];
              if (child.nodeType === 1) {
                _results.push(child);
              }
            }
            return _results;
          })();
          for (_j = 0, _len1 = children.length; _j < _len1; _j++) {
            child = children[_j];
            initElement(child, parent);
          }
          if (!parent.inited) {
            checkChildren = function() {
              var _k, _len2;
              for (_k = 0, _len2 = children.length; _k < _len2; _k++) {
                child = children[_k];
                if (!child.inited && child.localName === !'class') {
                  setTimeout(checkChildren, 0);
                  return;
                }
              }
              parent.inited = true;
              parent.sendEvent('init', parent);
            };
            setTimeout(checkChildren, 0);
          }
        }
      };
      writeCSS = function() {
        var style;
        style = document.createElement('style');
        style.type = 'text/css';
        style.innerHTML = '.sprite{ position: absolute; pointer-events: none; padding: 0; margin: 0; box-sizing:border-box;} .sprite-text{ width: auto; height; auto; white-space: nowrap;  padding: 0; margin: 0;} .sprite-inputtext{border: none; outline: none; background-color:transparent; resize:none;} .hidden{ display: none; } .noselect{ -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;} method { display: none; } handler { display: none; } setter { display: none; } class { display:none } node { display:none } dataset { display:none } .warnings {font-size: 14px; background-color: pink; margin: 0;}';
        return document.getElementsByTagName('head')[0].appendChild(style);
      };
      initAllElements = function(selector) {
        var el, _i, _len;
        if (selector == null) {
          selector = $('view').not('view view');
        }
        for (_i = 0, _len = selector.length; _i < _len; _i++) {
          el = selector[_i];
          initFromElement(el);
        }
      };
      htmlDecode = function(input) {
        var child, e, out, _i, _len, _ref;
        e = document.createElement('div');
        e.innerHTML = input;
        out = '';
        _ref = e.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if ((child.nodeValue != null) && (child.nodeType === 3 || child.nodeType === 8)) {
            out += child.nodeValue;
          } else {
            return;
          }
        }
        return out;
      };
      processSpecialTags = function(el, classattributes, defaulttype) {
        var args, attributes, child, children, handler, name, script, tagname, type, _base, _base1, _i, _len, _name, _ref, _ref1;
        if (classattributes.$types == null) {
          classattributes.$types = {};
        }
        if (classattributes.$methods == null) {
          classattributes.$methods = {};
        }
        if (classattributes.$handlers == null) {
          classattributes.$handlers = [];
        }
        children = getChildren(el);
        for (_i = 0, _len = children.length; _i < _len; _i++) {
          child = children[_i];
          attributes = flattenattributes(child.attributes);
          tagname = child.localName;
          args = ((_ref = attributes.args) != null ? _ref : '').split();
          script = htmlDecode(child.innerHTML);
          if (script == null) {
            console.warn('Invalid tag', name, child);
          }
          type = (_ref1 = attributes.type) != null ? _ref1 : defaulttype;
          name = attributes.name;
          checkRequiredAttributes(tagname, attributes, child, el);
          switch (tagname) {
            case 'handler':
              handler = {
                name: name,
                ev: attributes.event,
                script: compiler.transform(script, type),
                args: args,
                reference: attributes.reference,
                method: attributes.method
              };
              classattributes.$handlers.push(handler);
              break;
            case 'method':
              if ((_base = classattributes.$methods)[name] == null) {
                _base[name] = [];
              }
              classattributes.$methods[name].push({
                method: compiler.transform(script, type),
                args: args,
                allocation: attributes.allocation,
                invokeSuper: attributes.invokesuper
              });
              break;
            case 'setter':
              name = name.toLowerCase();
              if ((_base1 = classattributes.$methods)[_name = 'set_' + name] == null) {
                _base1[_name] = [];
              }
              classattributes.$methods['set_' + name].push({
                method: compiler.transform(script, type),
                args: args,
                allocation: attributes.allocation,
                invokeSuper: attributes.invokesuper
              });
              break;
            case 'attribute':
              name = name.toLowerCase();
              classattributes[name] = attributes.value;
              classattributes.$types[name] = attributes.type;
              if ('visual' in attributes) {
                hiddenAttributes[name] = attributes.visual === 'false';
              }
          }
        }
        return children;
      };
      return exports = {
        initAllElements: initAllElements,
        initElement: initElement,
        processSpecialTags: processSpecialTags,
        writeCSS: writeCSS
      };

      /**
         * @class dr.state {Core Dreem}
         * @extends dr.node
         * Allows a group of attributes, methods, handlers and instances to be removed and applied as a group.
         * 
         * Like views and nodes, states can contain methods, handlers, setters, constraints, attributes and other view, node or class instances.
         *
         * Currently, states must end with the string 'state' in their name to work properly.
         *
         *     @example
         *     <spacedlayout axis="y"></spacedlayout>
         *     <view id="square" width="100" height="100" bgcolor="lightgrey">
         *       <attribute name="ispink" type="boolean" value="false"></attribute>
         *       <state name="pinkstate" applied="${this.parent.ispink}">
         *         <attribute name="bgcolor" value="pink" type="string"></attribute>
         *       </state>
         *     </view>
         *     <labelbutton text="pinkify!">
         *       <handler event="onclick">
         *         square.setAttribute('ispink', true);
         *       </handler>
         *     </labelbutton>
         *
       */
    })();
    State = (function(_super) {
      __extends(State, _super);

      function State(el, attributes) {
        var child, compilertype, handler, instancebody, name, oldbody, processedChildren, value, _i, _j, _len, _len1, _ref, _ref1;
        if (attributes == null) {
          attributes = {};
        }
        this.skipattributes = ['parent', 'types', 'applyattributes', 'applied', 'skipattributes', 'stateattributes'];
        this.stateattributes = attributes;
        this.applyattributes = {};
        this.applied = false;
        compilertype = attributes.type;
        processedChildren = dom.processSpecialTags(el, attributes, compilertype);
        oldbody = el.innerHTML.trim();
        for (_i = 0, _len = processedChildren.length; _i < _len; _i++) {
          child = processedChildren[_i];
          child.parentNode.removeChild(child);
        }
        instancebody = el.innerHTML.trim();
        if (oldbody) {
          el.innerHTML = oldbody;
        }
        this.types = (_ref = attributes.$types) != null ? _ref : {};
        this.setAttribute('parent', attributes.parent);
        this.installMethods(attributes.$methods, this.parent.$tagname, this, this.parent);
        if (attributes.name) {
          this.setAttribute('name', attributes.name);
          this.skipattributes.push('name');
        }
        if (attributes.applied) {
          this.bindAttribute('applied', attributes.applied, 'state');
        }
        _ref1 = attributes.$handlers;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          handler = _ref1[_j];
          if (handler.ev === 'onapplied') {
            this.installHandlers([handler], 'state', this);
            this._bindHandlers();
          }
        }
        for (name in attributes) {
          value = attributes[name];
          if (!(__indexOf.call(this.skipattributes, name) >= 0 || name.charAt(0) === '$')) {
            this.applyattributes[name] = value;
            this.setAttribute(name, value);
          }
        }
        if (this.constraints) {
          this._bindConstraints();
          this.skipattributes.push('constraints');
        }
        if (this.events) {
          this.skipattributes.push('events');
        }
        if (this.handlers) {
          this.skipattributes.push('handlers');
        }
        if (this.latehandlers) {
          this.skipattributes.push('latehandlers');
        }
        this.enumfalse(this.skipattributes);
        this.enumfalse(this.keys);
      }


      /**
       * @event onapplied 
       * Fired when the state has been applied or unapplied. Onapplied handlers run in the scope of the state itself, see dragstate for an example.
       * @param {Boolean} applied If true, the state was applied.
       */


      /**
       * @attribute {Boolean} [applied=false]
       * If true, the state is applied.
       */

      State.prototype.set_applied = function(applied) {
        var name, parentname, val;
        if (!this.parent) {
          return;
        }
        if (this.applied === applied) {
          return;
        }
        this.applied = applied;
        if (applied) {
          this.parent.learn(this);
          if (this.stateattributes.$handlers) {
            this.parent.installHandlers(this.stateattributes.$handlers, this.parent.$tagname, this.parent);
            this.parent._bindHandlers();
            this.parent._bindHandlers(true);
          }
        } else {
          this.parent.forget(this);
          if (this.stateattributes.$handlers) {
            this.parent.removeHandlers(this.stateattributes.$handlers, this.parent.$tagname, this.parent);
          }
        }
        parentname = this.parent.$tagname;
        for (name in this.applyattributes) {
          val = this.parent[name];
          if (val === void 0) {
            continue;
          }
          this.parent[name] = !val;
          this.parent.bindAttribute(name, val, parentname);
        }
      };

      State.prototype.apply = function() {
        if (!this.applied) {
          return this.setAttribute('applied', true);
        }
      };

      State.prototype.remove = function() {
        if (this.applied) {
          return this.setAttribute('applied', false);
        }
      };

      return State;

    })(Node);

    /**
     * @class dr.class {Core Dreem}
     * Allows new tags to be created. Classes only be created with the &lt;class>&lt;/class> tag syntax. 
     * 
     * Classes can extend any other class, and they extend dr.view by default. 
     * 
     * Once declared, classes invoked with the declarative syntax, e.g. &lt;classname>&lt;/classname>.
     * 
     * If a class can't be found in the document, dreem will automatically attempt to load it from the classes/* directory.
     *
     * Like views and nodes, classes can contain methods, handlers, setters, constraints, attributes and other view, node or class instances.
     *
     * Here is a class called 'tile' that extends dr.view. It sets the bgcolor, width, and height attributes. An instance of tile is created using declarative syntax.
     *
     *     @example
     *     <class name="tile" extends="view" bgcolor="thistle" width="100" height="100"></class>
     *
     *     <tile></tile>
     *
     * Now we'll extend the tile class with a class called 'labeltile', which contains a label inside of the box. We'll declare one each of tile and labeltile, and position them with a spacedlayout.
     *
     *     @example
     *     <class name="tile" extends="view" bgcolor="thistle" width="100" height="100"></class>
     *
     *     <class name="labeltile" extends="tile">
     *       <text text="Tile"></text>
     *     </class>
     *
     *     <spacedlayout></spacedlayout>
     *     <tile></tile>
     *     <labeltile></labeltile>
     *
     * Attributes that are declared inside of a class definition can be set when the instance is declared. Here we bind the label text to the value of an attribute called label.
     *
     *     @example
     *     <class name="tile" extends="view" bgcolor="thistle" width="100" height="100"></class>
     *
     *     <class name="labeltile" extends="tile">
     *       <attribute name="label" type="string" value=""></attribute>
     *       <text text="${this.parent.label}"></text>
     *     </class>
     *
     *     <spacedlayout></spacedlayout>
     *     <tile></tile>
     *     <labeltile label="The Tile"></labeltile>
     *
     */
    Class = (function() {

      /**
       * @attribute {String} name (required)
       * The name of the new tag.
       */

      /**
       * @attribute {String} [extends=view] 
       * The name of a class that should be extended.
       */

      /**
       * @attribute {"js"/"coffee"} [type=js] 
       * The default compiler to use for methods, setters and handlers. Either 'js' or 'coffee'
       */
      var clone;

      clone = function(obj) {
        var name, newobj, val;
        newobj = {};
        for (name in obj) {
          val = obj[name];
          newobj[name] = val;
        }
        return newobj;
      };

      function Class(el, classattributes) {
        var child, compilertype, extend, haschildren, ignored, instancebody, name, oldbody, processedChildren, _i, _len;
        if (classattributes == null) {
          classattributes = {};
        }
        name = (classattributes.name ? classattributes.name.toLowerCase() : classattributes.name);
        extend = classattributes["extends"] != null ? classattributes["extends"] : classattributes["extends"] = 'view';
        compilertype = classattributes.type;
        for (ignored in ignoredAttributes) {
          delete classattributes[ignored];
        }
        processedChildren = dom.processSpecialTags(el, classattributes, compilertype);
        oldbody = el.innerHTML.trim();
        for (_i = 0, _len = processedChildren.length; _i < _len; _i++) {
          child = processedChildren[_i];
          child.parentNode.removeChild(child);
        }
        haschildren = ((function() {
          var _j, _len1, _ref, _results;
          _ref = el.childNodes;
          _results = [];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            child = _ref[_j];
            if (child.nodeType === 1) {
              _results.push(child);
            }
          }
          return _results;
        })()).length > 0;
        instancebody = el.innerHTML.trim();
        if (oldbody) {
          el.innerHTML = oldbody;
        }
        if (name in dr) {
          console.warn('overwriting class', name);
        }
        dr[name] = function(instanceel, instanceattributes) {
          var attributes, checkChildren, children, key, parent, propname, sendInit, val, value, viewel, _j, _len1, _ref;
          attributes = clone(classattributes);
          for (key in instanceattributes) {
            value = instanceattributes[key];
            if ((key === '$methods' || key === '$types') && key in attributes) {
              attributes[key] = clone(attributes[key]);
              for (propname in value) {
                val = value[propname];
                if (key === '$methods' && attributes[key][propname]) {
                  attributes[key][propname] = attributes[key][propname].concat(val);
                } else {
                  attributes[key][propname] = val;
                }
              }
            } else if (key === '$handlers' && key in attributes) {
              attributes[key] = attributes[key].concat(value);
            } else {
              attributes[key] = value;
            }
          }
          if (!(extend in dr)) {
            console.warn('could not find class for tag', extend);
            return;
          }
          if (attributes.$tagname === 'class' || !attributes.$tagname) {
            attributes.$tagname = name;
          }
          attributes.$skiponinit = true;
          attributes.$deferbindings = haschildren;
          parent = new dr[extend](instanceel, attributes);
          viewel = (_ref = parent.sprite) != null ? _ref.el : void 0;
          if (instanceel) {
            if (!viewel) {
              instanceel.setAttribute('class', 'hidden');
            }
          }
          if (instancebody && viewel) {
            if (viewel.innerHTML) {
              viewel.innerHTML = instancebody + viewel.innerHTML;
            } else {
              viewel.innerHTML = instancebody;
            }
            children = (function() {
              var _j, _len1, _ref1, _results;
              _ref1 = viewel.childNodes;
              _results = [];
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                child = _ref1[_j];
                if (child.nodeType === 1) {
                  _results.push(child);
                }
              }
              return _results;
            })();
            for (_j = 0, _len1 = children.length; _j < _len1; _j++) {
              child = children[_j];
              dom.initElement(child, parent);
            }
          }
          sendInit = function() {
            if (parent.inited) {
              return;
            }
            parent._bindHandlers();
            parent._bindHandlers(true);
            parent.inited = true;
            return parent.sendEvent('init', parent);
          };
          if (children != null ? children.length : void 0) {
            checkChildren = function() {
              var _k, _len2;
              for (_k = 0, _len2 = children.length; _k < _len2; _k++) {
                child = children[_k];
                if (!child.inited && child.localName === !'class') {
                  setTimeout(checkChildren, 0);
                  return;
                }
              }
              return sendInit();
            };
            setTimeout(checkChildren, 0);
          } else {
            sendInit();
          }
          return parent;
        };
      }

      return Class;

    })();

    /**
     * @class dr.layout {Layout}
     * @extends dr.node
     * The base class for all layouts. 
     *
     * When a new layout is added, it will automatically create and add itself to a layouts array in its parent. In addition, an onlayouts event is fired in the parent when the layouts array changes. This allows the parent to access the layout(s) later.
     *
     * Here is a view that contains both a spacedlayout and a shrinktofit.
     *
     *     @example
     *     <spacedlayout axis="y"></spacedlayout>
     *     <view bgcolor="oldlace">
     *       <shrinktofit axis="both"></shrinktofit>
     *
     *       <spacedlayout></spacedlayout>
     *
     *       <view width="50" height="50" bgcolor="lightpink" opacity=".3"></view>
     *       <view width="50" height="50" bgcolor="plum" opacity=".3"></view>
     *       <view width="50" height="50" bgcolor="lightblue" opacity=".3"></view>
     *
     *       <handler event="onlayouts" args="layouts">
     *         output.setAttribute('text', output.text||'' + "New layout added: " + layouts[layouts.length-1].$tagname + "\n");
     *       </handler>
     *     </view>
     *
     *     <text id="output" multiline="true" width="300"></text>
     *
     *
     */
    Layout = (function(_super) {
      __extends(Layout, _super);

      function Layout(el, attributes) {
        var subview, subviews, _base, _i, _len;
        if (attributes == null) {
          attributes = {};
        }
        this.locked = true;
        this.subviews = [];
        Layout.__super__.constructor.apply(this, arguments);
        this.listenTo(this.parent, 'subviewAdded', this.addSubview.bind(this));
        this.listenTo(this.parent, 'subviewRemoved', this.removeSubview.bind(this));
        this.listenTo(this.parent, 'init', this.update);
        if ((_base = this.parent).layouts == null) {
          _base.layouts = [];
        }
        this.parent.layouts.push(this);
        subviews = this.parent.subviews;
        if (subviews) {
          for (_i = 0, _len = subviews.length; _i < _len; _i++) {
            subview = subviews[_i];
            this.addSubview(subview);
          }
        }
        this.locked = false;
        this.update();
      }

      Layout.prototype.destroy = function(skipevents) {
        this.locked = true;
        Layout.__super__.destroy.apply(this, arguments);
        if (!skipevents) {
          return this._removeFromParent('layouts');
        }
      };


      /**
       * Adds the provided view to the subviews array of this layout.
       * @param {dr.view} view The view to add to this layout.
       * @return {void}
       */

      Layout.prototype.addSubview = function(view) {
        if (this.ignore(view)) {
          return;
        }
        this.subviews.push(view);
        this.startMonitoringSubview(view);
        if (!this.locked) {
          return this.update();
        }
      };


      /**
       * Removes the provided View from the subviews array of this Layout.
       * @param {dr.view} view The view to remove from this layout.
       * @return {number} the index of the removed subview or -1 if not removed.
       */

      Layout.prototype.removeSubview = function(view) {
        var idx;
        if (this.ignore(view)) {
          return -1;
        }
        idx = this.subviews.indexOf(view);
        if (idx !== -1) {
          this.stopMonitoringSubview(view);
          this.subviews.splice(idx, 1);
          if (!this.locked) {
            this.update();
          }
        }
        return idx;
      };


      /**
       * Checks if a subview can be added to this Layout or not. The default 
       * implementation returns the 'ignorelayout' attributes of the subview.
       * @param {dr.view} view The view to check.
       * @return {boolean} True means the subview will be skipped, false otherwise.
       */

      Layout.prototype.ignore = function(view) {
        return view.ignorelayout;
      };


      /**
       * Subclasses should implement this method to start listening to
       * events from the subview that should trigger the update method.
       * @param {dr.view} view The view to start monitoring for changes.
       * @return {void}
       */

      Layout.prototype.startMonitoringSubview = function(view) {};


      /**
       * Calls startMonitoringSubview for all views. Used by layout 
       * implementations when a change occurs to the layout that requires
       * refreshing all the subview monitoring.
       * @return {void}
       */

      Layout.prototype.startMonitoringAllSubviews = function() {
        var i, svs, _results;
        svs = this.subviews;
        i = svs.length;
        _results = [];
        while (i) {
          _results.push(this.startMonitoringSubview(svs[--i]));
        }
        return _results;
      };


      /**
       * Subclasses should implement this method to stop listening to
       * events from the subview that would trigger the update method. This
       * should remove all listeners that were setup in startMonitoringSubview.
       * @param {dr.view} view The view to stop monitoring for changes.
       * @return {void}
       */

      Layout.prototype.stopMonitoringSubview = function(view) {};


      /**
       * Calls stopMonitoringSubview for all views. Used by Layout 
       * implementations when a change occurs to the layout that requires
       * refreshing all the subview monitoring.
       * @return {void}
       */

      Layout.prototype.stopMonitoringAllSubviews = function() {
        var i, svs, _results;
        svs = this.subviews;
        i = svs.length;
        _results = [];
        while (i) {
          _results.push(this.stopMonitoringSubview(svs[--i]));
        }
        return _results;
      };


      /**
       * Checks if the layout is locked or not. Should be called by the
       * "update" method of each layout to check if it is OK to do the update.
       * @return {boolean} true if not locked, false otherwise.
       */

      Layout.prototype.canUpdate = function() {
        return !this.locked && this.parent.inited;
      };


      /**
       * Updates the layout. Subclasses should call canUpdate to check lock state
       * before doing anything.
       * @return {void}
       */

      Layout.prototype.update = function() {};

      return Layout;

    })(Node);
    idle = (function() {
      var doTick, requestAnimationFrame, tickEvents, ticking;
      requestAnimationFrame = (function() {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
          return window.setTimeout(callback, 1000 / 60);
        };
      })();
      ticking = false;
      tickEvents = [];
      doTick = function(time) {
        var key;
        for (key in tickEvents) {
          if (tickEvents[key]) {
            tickEvents[key](time);
            tickEvents[key] = null;
          }
        }
        return ticking = false;
      };
      return function(key, callback) {
        if (!ticking) {
          requestAnimationFrame(doTick);
        }
        ticking = true;
        return tickEvents[key] = callback;
      };
    })();
    StartEventable = (function(_super) {
      __extends(StartEventable, _super);

      function StartEventable() {
        this.stopEvent = __bind(this.stopEvent, this);
        this.startEvent = __bind(this.startEvent, this);
        return StartEventable.__super__.constructor.apply(this, arguments);
      }

      StartEventable.prototype.bind = function(ev, callback) {
        StartEventable.__super__.bind.apply(this, arguments);
        if (this.startEventTest()) {
          return this.startEvent();
        }
      };

      StartEventable.prototype.unbind = function(ev, callback) {
        StartEventable.__super__.unbind.apply(this, arguments);
        if (!this.startEventTest()) {
          return this.stopEvent();
        }
      };

      StartEventable.prototype.startEvent = function(event) {
        if (this.eventStarted) {
          return;
        }
        return this.eventStarted = true;
      };

      StartEventable.prototype.stopEvent = function(event) {
        if (!this.eventStarted) {
          return;
        }
        return this.eventStarted = false;
      };

      return StartEventable;

    })(Eventable);

    /**
     * @class dr.idle {Util}
     * @extends Eventable
     * Sends onidle events when the application is active and idle.
     *
     *     @example
     *     <handler event="onidle" reference="dr.idle" args="idleStatus">
     *       milis.setAttribute('text', idleStatus);
     *     </handler>
     *
     *     <spacedlayout></spacedlayout>
     *     <text text="Miliseconds since app started: "></text>
     *     <text id="milis"></text>
     */
    Idle = (function(_super) {
      __extends(Idle, _super);

      function Idle() {
        this.sender = __bind(this.sender, this);
        this.startEvent = __bind(this.startEvent, this);
        return Idle.__super__.constructor.apply(this, arguments);
      }

      Idle.prototype.startEventTest = function() {
        var start, _ref;
        start = (_ref = this.events['idle']) != null ? _ref.length : void 0;
        if (start) {
          return start;
        }
      };

      Idle.prototype.startEvent = function(event) {
        Idle.__super__.startEvent.apply(this, arguments);
        return idle(1, this.sender);
      };

      Idle.prototype.sender = function(time) {

        /**
         * @event onidle 
         * Fired when the application is active and idle.
         * @param {Number} time The number of milliseconds since the application started
         */
        this.sendEvent('idle', time);
        return setTimeout((function(_this) {
          return function() {
            return idle(1, _this.sender);
          };
        })(this), 0);
      };

      return Idle;

    })(StartEventable);
    mouseEvents = ['click', 'mouseover', 'mouseout', 'mousedown', 'mouseup'];

    /**
     * @class dr.mouse {Input}
     * @extends Eventable
     * Sends mouse events. Often used to listen to onmouseover/x/y events to follow the mouse position.
     *
     * Here we attach events handlers to the onx and ony events of dr.mouse, and set the x,y coordinates of a square view so it follows the mouse.
     *
     *     @example
     *     <view id="mousetracker" width="20" height="20" bgcolor="MediumTurquoise"></view>
     *
     *     <handler event="onx" args="x" reference="dr.mouse">
     *       mousetracker.setAttribute('x', x);
     *     </handler>
     *
     *     <handler event="ony" args="y" reference="dr.mouse">
     *       mousetracker.setAttribute('y', y);
     *     </handler>
     *
     *
     */
    Mouse = (function(_super) {
      var lastTouchDown, lastTouchOver, skipEvent;

      __extends(Mouse, _super);


      /**
       * @event onclick 
       * Fired when the mouse is clicked
       * @param {dr.view} view The dr.view that fired the event
       */


      /**
       * @event onmouseover 
       * Fired when the mouse moves over a view
       * @param {dr.view} view The dr.view that fired the event
       */


      /**
       * @event onmouseout 
       * Fired when the mouse moves off a view
       * @param {dr.view} view The dr.view that fired the event
       */


      /**
       * @event onmousedown 
       * Fired when the mouse goes down on a view
       * @param {dr.view} view The dr.view that fired the event
       */


      /**
       * @event onmouseup 
       * Fired when the mouse goes up on a view
       * @param {dr.view} view The dr.view that fired the event
       */

      function Mouse() {
        this.sender = __bind(this.sender, this);
        this.handle = __bind(this.handle, this);
        this.touchHandler = __bind(this.touchHandler, this);
        this.x = 0;
        this.y = 0;
        this.docSelector = $(document);
        this.docSelector.on(mouseEvents.join(' '), this.handle);
        this.docSelector.on("mousemove", this.handle).one("mouseout", this.stopEvent);
        if (capabilities.touch) {
          document.addEventListener('touchstart', this.touchHandler, true);
          document.addEventListener('touchmove', this.touchHandler, true);
          document.addEventListener('touchend', this.touchHandler, true);
          document.addEventListener('touchcancel', this.touchHandler, true);
        }
      }

      skipEvent = function(e) {
        if (e.stopPropagation) {
          e.stopPropagation();
        }
        if (e.preventDefault) {
          e.preventDefault();
        }
        e.cancelBubble = true;
        e.returnValue = false;
        return false;
      };

      Mouse.prototype.startEventTest = function() {
        var _ref, _ref1, _ref2;
        return ((_ref = this.events['mousemove']) != null ? _ref.length : void 0) || ((_ref1 = this.events['x']) != null ? _ref1.length : void 0) || ((_ref2 = this.events['y']) != null ? _ref2.length : void 0);
      };

      Mouse.prototype.sendMouseEvent = function(type, first) {
        var simulatedEvent;
        simulatedEvent = document.createEvent('MouseEvent');
        simulatedEvent.initMouseEvent(type, true, true, window, 1, first.pageX, first.pageY, first.clientX, first.clientY, false, false, false, false, 0, null);
        first.target.dispatchEvent(simulatedEvent);
        if (first.target.$view) {
          if (!(first.target.$view instanceof InputText)) {
            return skipEvent(event);
          }
        }
      };

      lastTouchDown = null;

      lastTouchOver = null;

      Mouse.prototype.touchHandler = function(event) {
        var first, over, touches;
        touches = event.changedTouches;
        first = touches[0];
        switch (event.type) {
          case 'touchstart':
            this.sendMouseEvent('mouseover', first);
            this.sendMouseEvent('mousedown', first);
            return lastTouchDown = first.target;
          case 'touchmove':
            over = document.elementFromPoint(first.pageX - window.pageXOffset, first.pageY - window.pageYOffset);
            if (over && over.$view) {
              if (lastTouchOver && lastTouchOver !== over) {
                this.handle({
                  target: lastTouchOver,
                  type: 'mouseout'
                });
              }
              lastTouchOver = over;
              this.handle({
                target: over,
                type: 'mouseover'
              });
            }
            return this.sendMouseEvent('mousemove', first);
          case 'touchend':
            this.sendMouseEvent('mouseup', first);
            if (lastTouchDown === first.target) {
              this.sendMouseEvent('click', first);
              return lastTouchDown = null;
            }
        }
      };

      Mouse.prototype.handle = function(event) {
        var type, view;
        view = event.target.$view;
        type = event.type;
        if (view) {
          if (type === 'mousedown') {
            this._lastMouseDown = view;
            if (!(view instanceof InputText)) {
              skipEvent(event);
            }
          }
        }
        if (type === 'mouseup' && this._lastMouseDown && this._lastMouseDown !== view) {
          this.sendEvent('mouseup', this._lastMouseDown);
          this._lastMouseDown.sendEvent('mouseup', this._lastMouseDown);
          this.sendEvent('mouseupoutside', this._lastMouseDown);
          this._lastMouseDown.sendEvent('mouseupoutside', this._lastMouseDown);
          this._lastMouseDown = null;
          return;
        } else if (view) {
          view.sendEvent(type, view);
        }

        /**
         * @property {Number} x
         * @readonly
         * The x coordinate of the mouse
         */
        this.x = event.pageX;

        /**
         * @property {Number} y
         * @readonly
         * The y coordinate of the mouse
         */
        this.y = event.pageY;
        if (this.eventStarted && type === 'mousemove') {
          return idle(0, this.sender);
        } else {
          return this.sendEvent(type, view);
        }
      };

      Mouse.prototype.sender = function() {

        /**
         * @event onmousemove 
         * Fired when the mouse moves
         * @param {Object} coordinates The x and y coordinates of the mouse
         */
        this.sendEvent("mousemove", {
          x: this.x,
          y: this.y
        });

        /**
         * @event onx 
         * Fired when the mouse moves in the x axis
         * @param {Number} x The x coordinate of the mouse
         */
        this.sendEvent('x', this.x);

        /**
         * @event ony 
         * Fired when the mouse moves in the y axis
         * @param {Number} y The y coordinate of the mouse
         */
        return this.sendEvent('y', this.y);
      };

      Mouse.prototype.handleDocEvent = function(event) {
        if (event && event.target !== document) {
          return;
        }
        if (this.eventStarted) {
          return this.docSelector.on("mousemove", this.handle).one("mouseout", this.stopEvent);
        } else {
          return this.docSelector.on("mousemove", this.handle).one("mouseout", this.startEvent);
        }
      };

      return Mouse;

    })(StartEventable);

    /**
     * @class dr.window {Util}
     * @extends Eventable
     * Sends window resize events. Often used to dynamically reposition views as the window size changes.
     *
     *     <handler event="onwidth" reference="dr.window" args="newWidth">
     *       //adjust views
     *     </handler>
     *
     *     <handler event="onheight" reference="dr.window" args="newHeight">
     *       //adjust views
     *     </handler>
     *
     *
     */
    Window = (function(_super) {
      __extends(Window, _super);

      function Window() {
        this.handle = __bind(this.handle, this);
        var handleVisibilityChange, hidden, visibilityChange;
        window.addEventListener('resize', this.handle, false);
        this.visible = true;
        if (document.hidden != null) {
          hidden = "hidden";
          visibilityChange = "visibilitychange";
        } else if (document.mozHidden != null) {
          hidden = "mozHidden";
          visibilityChange = "mozvisibilitychange";
        } else if (document.msHidden != null) {
          hidden = "msHidden";
          visibilityChange = "msvisibilitychange";
        } else if (document.webkitHidden != null) {
          hidden = "webkitHidden";
          visibilityChange = "webkitvisibilitychange";
        }
        handleVisibilityChange = (function(_this) {
          return function() {
            _this.visible = document[hidden];

            /**
             * @event onvisible 
             * Fired when the window visibility changes
             * @param {Boolean} visible True if the window is currently visible
             */
            return _this.sendEvent('visible', _this.visible);
          };
        })(this);
        document.addEventListener(visibilityChange, handleVisibilityChange, false);
        this.handle();
      }

      Window.prototype.startEventTest = function() {
        var _ref, _ref1;
        return ((_ref = this.events['width']) != null ? _ref.length : void 0) || ((_ref1 = this.events['height']) != null ? _ref1.length : void 0);
      };

      Window.prototype.handle = function(event) {
        this.width = window.innerWidth;

        /**
         * @event onwidth 
         * Fired when the window resizes
         * @param {Number} width The width of the window
         */
        this.sendEvent('width', this.width);
        this.height = window.innerHeight;

        /**
         * @event onheight 
         * Fired when the window resizes
         * @param {Number} height The height of the window
         */
        return this.sendEvent('height', this.height);
      };

      return Window;

    })(StartEventable);

    /**
     * @class dr.keyboard {Input}
     * @extends Eventable
     * Sends keyboard events.
     *
     * You might want to track specific keyboard events when text is being entered into an input box. In this example we listen for the enter key and display the value.
     *
     *     @example
     *     <spacedlayout axis="y" spacing="25"></spacedlayout>
     *     <inputtext id="nameinput" bgcolor="lightgrey"></inputtext>
     *     <text id="keycode" text="Key Code:"></text>
     *     <text id="entered"></text>
     *
     *     <handler event="onkeyup" args="keys" reference="dr.keyboard">
     *       keycode.setAttribute('text', 'Key Code: ' + keys.keyCode);
     *       if (keys.keyCode == 13) {
     *         entered.setAttribute('text', 'You entered: ' + nameinput.text);
     *         nameinput.setAttribute('text', '');
     *       }
     *     </handler>
     */
    Keyboard = (function(_super) {
      var keyboardEvents, keys;

      __extends(Keyboard, _super);

      keyboardEvents = ['select', 'keyup', 'keydown', 'change'];

      keys = {
        shiftKey: false,
        altKey: false,
        ctrlKey: false,
        metaKey: false,
        keyCode: 0
      };

      function Keyboard() {
        this.handle = __bind(this.handle, this);
        $(document).on(keyboardEvents.join(' '), this.handle);
      }

      Keyboard.prototype.handle = function(event) {
        var key, out, target, type, value;
        target = event.target.$view;
        type = event.type;
        if (type !== 'select') {
          for (key in keys) {
            value = keys[key];
            keys[key] = event[key];
          }
        }
        keys.type = type;
        if (target) {
          target.sendEvent(type, keys);
          if (type === 'keydown' || type === 'keyup' || type === 'blur' || type === 'change') {
            value = event.target.value;
            if (target.text !== value) {
              target.text = value;
              target.sendEvent('text', value);
            }
          }
        }
        out = type === 'select' ? target : keys;

        /**
         * @event onselect 
         * Fired when text is selected
         * @param {dr.view} view The view that fired the event
         */

        /**
         * @event onchange 
         * Fired when an inputtext has changed
         * @param {dr.view} view The view that fired the event
         */

        /**
         * @event onkeydown 
         * Fired when a key goes down
         * @param {Object} keys An object representing the keyboard state, including shiftKey, allocation, ctrlKey, metaKey, keyCode and type
         */

        /**
         * @event onkeyup 
         * Fired when a key goes up
         * @param {Object} keys An object representing the keyboard state, including shiftKey, allocation, ctrlKey, metaKey, keyCode and type
         */
        this.sendEvent(type, out);

        /**
         * @event onkeys 
         * Fired when a key is pressed on the keyboard
         * @param {Object} keys An object representing the keyboard state, including shiftKey, allocation, ctrlKey, metaKey, keyCode and type
         */
        if (type !== 'select') {
          return this.sendEvent('keys', out);
        }
      };

      return Keyboard;

    })(Eventable);

    /**
     * @class dr {Core Dreem}
     * Holds builtin and user-created classes and public APIs.
     * 
     * All classes listed here can be invoked with the declarative syntax, e.g. &lt;node>&lt;/node> or &lt;view>&lt;/view>
     */
    return exports = {
      view: View,
      text: Text,
      inputtext: InputText,
      "class": Class,
      node: Node,
      mouse: new Mouse(),
      keyboard: new Keyboard(),
      window: new Window(),
      layout: Layout,
      idle: new Idle(),
      state: State,

      /**
       * @method initElements
       * Initializes all top-level views found in the document. Called automatically when the page loads, but can be called manually as needed.
       */
      initElements: dom.initAllElements,

      /**
       * @method writeCSS
       * Writes generic dreem-specific CSS to the document. Should only be called once.
       */
      writeCSS: dom.writeCSS
    };

    /**
     * @class dr.method {Core Dreem}
     * Declares a member function in a node, view, class or other class instance. Methods can only be created with the &lt;method>&lt;/method> tag syntax.
     * 
     * If a method overrides an existing method, any existing (super) method(s) will be called first automatically.
     *
     * Let's define a method called changeColor in a view that sets the background color to pink.
     *
     *     @example
     *
     *     <view id="square" width="100" height="100">
     *       <method name="changeColor">
     *         this.setAttribute('bgcolor', 'pink');
     *       </method>
     *     </view>
     *
     *     <handler event="oninit">
     *       square.changeColor();
     *     </handler>
     *
     * Here we define the changeColor method in a class called square. We create an instance of the class and call the method on the intance.
     *
     *     @example
     *     <class name="square" width="100" height="100">
     *       <method name="changeColor">
     *         this.setAttribute('bgcolor', 'pink');
     *       </method>
     *     </class>
     *
     *     <square id="square1"></square>
     *
     *     <handler event="oninit">
     *       square1.changeColor();
     *     </handler>
     *
     * Now we'll subclass the square class with a bluesquare class, and override the changeColor method to color the square blue. We also add an inner square who's color is set in the changeColor method of the square superclass. Notice that the color of this square is set when the method is called on the subclass.
     *
     *     @example
     *     <class name="square" width="100" height="100">
     *       <view name="inner" width="25" height="25"></view>
     *       <method name="changeColor">
     *         this.inner.setAttribute('bgcolor', 'green');
     *         this.setAttribute('bgcolor', 'pink');
     *       </method>
     *     </class>
     *
     *     <class name="bluesquare" extends="square">
     *       <method name="changeColor">
     *         this.setAttribute('bgcolor', 'blue');
     *       </method>
     *     </class>
     *
     *     <spacedlayout></spacedlayout>
     *
     *     <square id="square1"></square>
     *     <bluesquare id="square2"></bluesquare>
     *
     *     <handler event="oninit">
     *       square1.changeColor();
     *       square2.changeColor();
     *     </handler>
     *
     */

    /**
     * @attribute {String} name (required)
     * The name of the method.
     */

    /**
     * @attribute {String[]} args
     * A comma separated list of method arguments.
     */

    /**
     * @attribute {"js"/"coffee"} type 
     * The compiler to use for this method. Inherits from the immediate class if unspecified.
     */

    /**
     * @class dr.setter
     * Declares a setter in a node, view, class or other class instance. Setters can only be created with the &lt;setter>&lt;/setter> tag syntax.
     *
     * Setters allow the default behavior of attribute changes to be changed.
     * 
     * Like dr.method, if a setter overrides an existing setter any existing (super) setter(s) will be called first automatically.
     * @ignore
     */

    /**
     * @attribute {String} name (required)
     * The name of the method.
     */

    /**
     * @attribute {String[]} args
     * A comma separated list of method arguments.
     */

    /**
     * @attribute {"js"/"coffee"} type 
     * The compiler to use for this method. Inherits from the immediate class if unspecified.
     */

    /**
     * @class dr.handler {Core Dreem}
     * Declares a handler in a node, view, class or other class instance. Handlers can only be created with the `<handler></handler>` tag syntax.
     *
     * Handlers are called when an event fires with new value, if available.
     *
     * Here is a simple handler that listens for an onx event in the local scope. The handler runs when x changes:
     *
     *     <handler event="onx">
     *       // do something now that x has changed
     *     </handler>
     *
     * When a handler uses the args attribute, it can recieve the value that changed:
     *
     * Sometimes it's nice to use a single method to respond to multiple events:
     *
     *     <handler event="onx" method="handlePosition"></handler>
     *     <handler event="ony" method="handlePosition"></handler>
     *     <method name="handlePosition">
     *       // do something now that x or y have changed
     *     </method>
     *
     *
     * When a handler uses the args attribute, it can receive the value that changed:
     *
     *     @example
     *
     *     <handler event="onwidth" args="widthValue">
     *        exampleLabel.setAttribute("text", "Parent view received width value of " + widthValue)
     *     </handler>
     *
     *     <text id="exampleLabel" x="50" y="5" text="no value yet" color="coral" outline="1px dotted coral" padding="10px"></text>
     *     <text x="50" y="${exampleLabel.y + exampleLabel.height + 20}" text="no value yet" color="white" bgcolor="#DDAA00" padding="10px">
     *       <handler event="onwidth" args="wValue">
     *          this.setAttribute("text", "This label received width value of " + wValue)
     *       </handler>
     *     </text>
     *
     *
     * It's also possible to listen for events on another scope. This handler listens for onidle events on dr.idle instead of the local scope:
     *
     *     @example
     *
     *     <handler event="onidle" args="time" reference="dr.idle">
     *       exampleLabel.setAttribute('text', 'received time from dr.idle.onidle: ' + Math.round(time));
     *     </handler>
     *     <text id="exampleLabel" x="50" y="5" text="no value yet" color="coral" outline="1px dotted coral" padding="10px"></text>
     *
     *
     */

    /**
     * @attribute {String} event (required)
     * The name of the event to listen for, e.g. 'onwidth'.
     */

    /**
     * @attribute {String} reference
     * If set, the handler will listen for an event in another scope.
     */

    /**
     * @attribute {String} method
     * If set, the handler call a local method. Useful when multiple handlers need to do the same thing.
     */

    /**
     * @attribute {String[]} args
     * A comma separated list of method arguments.
     */

    /**
     * @attribute {"js"/"coffee"} type 
     * The compiler to use for this method. Inherits from the immediate class if unspecified.
     */

    /**
     * @class dr.attribute {Core Dreem}
     * Adds a variable to a node, view, class or other class instance. Attributes can only be created with the &lt;attribute>&lt;/attribute> tag syntax.
     * 
     * Attributes allow classes to declare new variables with a specific type and default value. 
     *
     * Attributes automatically send events when their value changes.
     *
     * Here we create a new class with a custom attribute representing a person's mood, along with two instances. One instance has the default mood of 'happy', the other sets the mood attribute to 'sad'. Note there's nothing visible in this example yet:
     *
     *     <class name="person">
     *       <attribute name="mood" type="string" value="happy"></attribute>
     *     </class>
     *
     *     <person></person>
     *     <person mood="sad"></person>
     *
     * Let's had a handler to make our color change with the mood. Whenever the mood attribute changes, the color changes with it:
     *
     *     @example
     *     <class name="person" width="100" height="100">
     *       <attribute name="mood" type="string" value="happy"></attribute>
     *       <handler event="onmood" args="mood">
     *         var color = 'orange';
     *         if (mood !== 'happy') {
     *           color = 'blue'
     *         }
     *         this.setAttribute('bgcolor', color);
     *       </handler>
     *     </class>
     * 
     *     <spacedlayout></spacedlayout>
     *     <person></person>
     *     <person mood="sad"></person>
     *
     * You can add as many attributes as you like to a class. Here, we add a numeric attribute for size, which changes the height and width attributes via a constraint:
     *
     *     @example
     *     <class name="person" width="${this.size}" height="${this.size}">
     *       <attribute name="mood" type="string" value="happy"></attribute>
     *       <handler event="onmood" args="mood">
     *         var color = 'orange';
     *         if (mood !== 'happy') {
     *           color = 'blue'
     *         }
     *         this.setAttribute('bgcolor', color);
     *       </handler>
     *       <attribute name="size" type="number" value="20"></attribute>
     *     </class>
     * 
     *     <spacedlayout></spacedlayout>
     *     <person></person>
     *     <person mood="sad" size="50"></person>
     */

    /**
     * @attribute {String} name (required)
     * The name of the attribute
     */

    /**
     * @attribute {"string"/"number"/"boolean"/"json"} [type=string] (required)
     * The type of the attribute. Used to convert from a string to an appropriate representation of the type.
     */

    /**
     * @attribute {String} value (required)
     * The initial value for the attribute
     */

    /**
     * @attribute {Boolean} [visible=true]
     * Set to false if an attribute shouldn't affect a view's visual appearence
     */
  })();

  dr.writeCSS();

  $(window).on('load', function() {
    dr.initElements();
    return hackstyle(true);
  });

}).call(this);

//# sourceMappingURL=layout.js.map
